<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hall">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hall">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hall">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hall</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hall</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">其实是一个备忘录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/tiny_socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/25/tiny_socket/" class="post-title-link" itemprop="url">用C++实现一个非常简单的socket即时通信机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-25 09:10:20" itemprop="dateCreated datePublished" datetime="2018-12-25T09:10:20+08:00">2018-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在这个简单的demo中，我们需要两个主要的部分</p>
<ol>
<li>服务器：能够接受新的客户端连接，并将每个客户端发过来的消息发给所有其他的客户端</li>
<li>客户端：能够连接服务器，并且向服务器发送信息</li>
</ol>
<p>这个是最简单的群聊功能, 以后有空的话考虑加入两个客户端之间的私聊功能, 第一版我不会加入太多的东西,包括但不限于线程池, 多线程编程, 超时重传, 确认收包( 当然还包括GUI )等特性在初版中我都不会涉及, 这一次的理解重点在于Linux epoll和C/S架构的理解</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>从之前的需求的大致整理,我们可以归纳出以下几条要点</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>连接服务器</li>
<li>支持用户输入信息,发送信息给服务器</li>
<li>接受并且显示服务器的信息</li>
<li>退出连接</li>
</ol>
<p>针对上述需求, 客户端实现需要两个进程, 分别支持下面的功能</p>
<p>对于子进程:</p>
<ol>
<li>等待用户输入聊天信息</li>
<li>将信息写入管道( pipe ) 中读取, 并且发送给服务器</li>
</ol>
<p>对于父进程:</p>
<ol>
<li>使用epoll机制接受接受服务器端发过来的信息, 并显示给用户, 使用户看到其他用户的聊天信息</li>
<li>将子进程写道pipe内的信息读取出来并且发送给服务器端</li>
</ol>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ol>
<li>支持多个客户端接入，实现聊天室基本功能</li>
<li>启动服务建立监听端口等待客户端连接</li>
<li>使用epoll机制实现并发，增加效率</li>
<li>客户端连接时发送欢迎消息并存储连接记录</li>
<li>客户端发送消息时广播给其他所有客户端</li>
<li>客户端请求退出时对连接信息进行清理</li>
</ol>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>模型采用C/S模型</p>
<ul>
<li>服务器端<ol>
<li>socket()创建监听socket</li>
<li>bind()绑定服务器端口</li>
<li>listen()监听客户端连接</li>
<li>accept()接受连接</li>
<li>recv/send接受和发送数据</li>
<li>close()关闭socket</li>
</ol>
</li>
</ul>
<ul>
<li>客户端<ol>
<li>socket()创建监听socket</li>
<li>connect()连接服务器</li>
<li>recv/send接受或者传送信息</li>
<li>close()关闭socket</li>
</ol>
</li>
</ul>
<h3 id="TCP服务端通信的常规步骤"><a href="#TCP服务端通信的常规步骤" class="headerlink" title="TCP服务端通信的常规步骤"></a>TCP服务端通信的常规步骤</h3><ol>
<li>使用socket()创建TCP套接字（socket）</li>
<li>将创建的套接字绑定到一个本地地址和端口上（Bind）</li>
<li>将套接字设为监听模式，准备接收客户端请求（listen）</li>
<li>等待客户请求到来: 当请求到来后，接受连接请求，返回一个对应于此次连接的新的套接字（accept）</li>
<li>用accept返回的套接字和客户端进行通信（使用write()/send()或send()/recv() )</li>
<li>返回，等待另一个客户请求</li>
<li>关闭套接字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server.cpp代码（通信模块）：</span></span><br><span class="line"><span class="comment">// 服务端地址 ip地址 + 端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">serverAddr.sin_family = PF_INET;</span><br><span class="line">serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(SERVER_HOST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端创建监听socket</span></span><br><span class="line"><span class="keyword">int</span> listener = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(listener &lt; <span class="number">0</span>) &#123; perror(<span class="string">"listener"</span>); <span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"listen socket created \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将服务端地址与监听socket绑定</span></span><br><span class="line"><span class="keyword">if</span>( bind(listener, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"bind error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line"><span class="keyword">int</span> ret = listen(listener, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123; perror(<span class="string">"listen error"</span>); <span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Start to listen: %s\n"</span>, SERVER_HOST);</span><br></pre></td></tr></table></figure>
<p>之后会提到accept和epoll的方法</p>
<h2 id="TCP客户端通信的常规步骤"><a href="#TCP客户端通信的常规步骤" class="headerlink" title="TCP客户端通信的常规步骤"></a>TCP客户端通信的常规步骤</h2><ol>
<li>创建套接字（socket）</li>
<li>使用connect()建立到达服务器的连接（connect)</li>
<li>客户端进行通信（使用write()/send()或send()/recv())</li>
<li>使用close()关闭客户连接</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client.cpp代码（通信模块）：</span></span><br><span class="line"><span class="comment">// 客户要连接的服务端地址（ ip地址 + 端口号）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">serverAddr.sin_family = PF_INET;</span><br><span class="line">serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字（socket）</span></span><br><span class="line"><span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sock &lt; <span class="number">0</span>) &#123; perror(<span class="string">"sock error"</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发出连接请求（connect）</span></span><br><span class="line"><span class="keyword">if</span>(connect(sock, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"connect error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于客户端如何实现管道之间的通信，以及与服务端之间的通信，在后面会详细介绍。</p>
<h2 id="基本技术"><a href="#基本技术" class="headerlink" title="基本技术"></a>基本技术</h2><h3 id="阻塞和非阻塞socket"><a href="#阻塞和非阻塞socket" class="headerlink" title="阻塞和非阻塞socket"></a>阻塞和非阻塞socket</h3><p>通常的,对一个文件描述符对应的文件或者是设备, 阻塞和非阻塞方式</p>
<ol>
<li>阻塞方式指的是: 当试图对该文件描述符进行读写的时候, 如果当时没有数据可读或者暂时不可写, 那么程序就进入等待状态, 知道有东西/空间可以读/写时, 程序接受到某个信号量被唤醒重新进入就绪队列( 操作系统 )</li>
<li>如果没有资源可写或者没有数据可读, 那么直接返回, 或者等一个特定的时间片再来寻求相应的资源</li>
</ol>
<p>两者的区别就是, 是否等待某一个信号量来重新唤醒。<br>我们这个小demo采用非阻塞的socket<br>这样能够充分利用服务器性能（<del>其实是偷懒比较方便</del>）</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>当服务端的在线人数越来越多，会导致系统资源吃紧，I/O效率越来越慢，这时候就应该考虑epoll了。epoll是Linux内核为处理大批句柄而作改进的poll，是Linux特有的I/O函数。其特点如下：</p>
<ol>
<li>epoll是Linux下多路复用IO接口select/poll的增强版本。其实现和使用方式与select/poll有很多不同，epoll通过一组函数来完成有关任务，而不是一个函数</li>
<li>epoll之所以高效，是因为epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/poll每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入就绪队列的描述符集合就行了。</li>
<li>epoll有两种工作方式，LT(level triggered)：水平触发和ET(edge-triggered)：边沿触发。LT是select/poll使用的触发方式，比较低效；而ET是epoll的高速工作方式，这次demo使用epoll的ET方式。</li>
</ol>
<p>想要了解epoll的可以康康 <a href="https://www.cnblogs.com/lojunren/p/3856290.html" title="这篇博客" target="_blank" rel="noopener">这篇博客</a> ，这篇博客的参考文献也挺有读一读的价值</p>
<p>咳咳，言归正传，我们看看epoll的C/C++接口长啥样子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll句柄，参数size用来告诉内核需要监听的文件描述符的数目，这个size是有上限的，随着内核的更新可能会不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件注册函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能： epoll事件注册函数</span></span><br><span class="line"><span class="comment">　 参数epfd为epoll的句柄，即epoll_create返回值</span></span><br><span class="line"><span class="comment">　 参数op表示动作，用3个宏来表示：</span></span><br><span class="line"><span class="comment">　　  EPOLL_CTL_ADD(注册新的fd到epfd)， </span></span><br><span class="line"><span class="comment">　EPOLL_CTL_MOD(修改已经注册的fd的监听事件)，</span></span><br><span class="line"><span class="comment">　　  EPOLL_CTL_DEL(从epfd删除一个fd)；</span></span><br><span class="line"><span class="comment">　　  其中参数fd为需要监听的标示符；</span></span><br><span class="line"><span class="comment">　 参数event告诉内核需要监听的事件，event的结构如下：</span></span><br><span class="line"><span class="comment">struct epoll_event &#123;</span></span><br><span class="line"><span class="comment">  __uint32_t events; //Epoll events</span></span><br><span class="line"><span class="comment">  epoll_data_t data; //User data variable</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">其中介绍events是宏的集合，本项目主要使用EPOLLIN(表示对应的文件描述符可以读，即读事件发生)，其他宏类型，可以google之！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件的产生，我猜可能有点类似C#中的async</span></span><br><span class="line"><span class="comment">// 函数返回需要处理的事件数目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因此服务端使用epoll的时候，步骤如下：</p>
<ol>
<li>调用epoll_create函数在Linux内核中创建一个事件表；</li>
<li>然后将文件描述符（监听套接字listener）添加到所创建的事件表中；</li>
<li>在主循环中，调用epoll_wait等待返回就绪的文件描述符集合；</li>
<li>分别处理就绪的事件集合，本项目中一共有两类事件：新用户连接事件和用户发来消息事件（epoll还有很多其他事件，这里我就不深入了以后有机会再开坑</li>
</ol>
<p>把一个socket添加到事件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件描述符fd添加到epollfd标示的内核事件表中， 并注册EPOLLIN和EPOOLET事件，EPOLLIN是数据可读事件；EPOOLET表明是ET工作方式。最后将文件描述符设置非阻塞方式</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param epollfd: epoll句柄</span></span><br><span class="line"><span class="comment">  * @param fd: 文件描述符</span></span><br><span class="line"><span class="comment">  * @param enable_et : enable_et = true, </span></span><br><span class="line"><span class="comment">     采用epoll的ET工 作方式；否则采用LT工作方式</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span>( enable_et )</span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd added to epoll!\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我们已经进行了一系列的分析，是时候进行一波实现了，又到了我最喜欢的coding环节</p>
<p>先进行一波初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化代码文件夹</span></span><br><span class="line">$ mkdir -p /home/hallwood/Code/learning/cpp/tiny_msg_demo</span><br><span class="line">$ <span class="built_in">cd</span> /home/hallwood/Code/learning/cpp/tiny_msg_demo</span><br><span class="line">$ mkdir header cpp</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装cmake</span></span><br><span class="line">$ sudo pacman -S cmake</span><br><span class="line">$ touch CMakeLists.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对应的文件</span></span><br><span class="line">$ touch Common.h Client.h Client.cpp ClientMain.cpp</span><br><span class="line">$ touch Server.h Server.cpp ServerMain.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件到对应的文件夹</span></span><br><span class="line">$ mv *.h ./header</span><br><span class="line">$ mv *.cpp ./cpp</span><br></pre></td></tr></table></figure>
<p>每个文件的作用:</p>
<ol>
<li>Common.h: 公共头文件</li>
<li>Client.h, Client.cpp: 客户端类实现</li>
<li>Server.h, Server.cpp: 服务器端实现</li>
<li>ClientMain.cpp,和ServerMain.cpp: 分别是客户端程序和服务器端程序的执行入口</li>
</ol>
<p>接下来我们开始逐渐实现我们需要的类</p>
<h2 id="Common-h"><a href="#Common-h" class="headerlink" title="Common.h"></a>Common.h</h2><p>这个头文件是Client程序和Server程序共用的， 我们只需要定义一个单独的函数被类成员函数调用即可，这个功能函数的作用就是之前提到的将文件描述符fd添加到epollfd标示的内核事件表中，因此我们把它卸载Common.h中，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/stl-analysis1-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/01/stl-analysis1-md/" class="post-title-link" itemprop="url">STL源码学习 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-01 02:58:20" itemprop="dateCreated datePublished" datetime="2018-12-01T02:58:20+08:00">2018-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以STL的运用角度而言,空间配置器是最不需要介绍的东西,它总是隐藏在一切组件后面，组件的实作时处处遇到挡路石。为什么不说allocator是内存配置器而说它是空间配置器呢?因为,空间不一定是内存,空间也可以是磁盘或其它辅助储存媒体。是的,你可以写一个 allocator,直接向硬盘取空间。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line">allocator::rebind</span><br><span class="line"><span class="comment">// 一个巢状的(nested)class template。class rebind&lt;U&gt;拥有唯一成员other,</span></span><br><span class="line"><span class="comment">// 那是一个 typedef,代表allocator&lt;U&gt;。</span></span><br><span class="line">allocator::allocator()</span><br><span class="line"><span class="comment">// default constructor。</span></span><br><span class="line">allocator::allocator(<span class="keyword">const</span></span><br><span class="line"> allocator&amp;)</span><br><span class="line"><span class="comment">// copy constructor。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;<span class="title">allocator</span>:</span>:allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span><br><span class="line"><span class="comment">// 泛化的copy constructor。</span></span><br><span class="line">allocator::~allocator()</span><br><span class="line"><span class="comment">// default constructor。</span></span><br><span class="line">pointer allocator::address(reference x) <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 传回某个对象的地址。算式a.address(x)等同于&amp;x。</span></span><br><span class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 传回某个const对象的地址。算式a.address(x)等同于&amp;x。</span></span><br><span class="line"></span><br><span class="line">pointer allocator::allocate(size_type n, cosnt <span class="keyword">void</span>* = <span class="number">0</span>)</span><br><span class="line"><span class="comment">//配置空间,足以储存n个T对象。第二自变量是个提示。实作上可能会利用它来</span></span><br><span class="line"><span class="comment">//增进区域性(locality),或完全忽略之。</span></span><br><span class="line"><span class="keyword">void</span> allocator::deallocate(pointer p, size_type n)</span><br><span class="line"><span class="comment">//归还先前配置的空间。</span></span><br><span class="line">size_type allocator::max_size() <span class="keyword">const</span></span><br><span class="line"><span class="comment">//传回可成功配置的最大量。</span></span><br><span class="line"><span class="keyword">void</span> allocator::construct(pointer p, <span class="keyword">const</span> T&amp; x)</span><br><span class="line"><span class="comment">//等同于new(const</span></span><br><span class="line"><span class="comment">// void*) p) T(x)。</span></span><br><span class="line"><span class="keyword">void</span> allocator::destroy(pointer p)</span><br><span class="line"><span class="comment">// 等同于p-&gt;~T()。</span></span><br></pre></td></tr></table></figure>
<h3 id="自己设计实现一个最简单的空间适配器"><a href="#自己设计实现一个最简单的空间适配器" class="headerlink" title="自己设计实现一个最简单的空间适配器"></a>自己设计实现一个最简单的空间适配器</h3><p><a href="https://github.com/HallWoodZhang/fakestl" title="代码" target="_blank" rel="noopener">代码</a> 文件分别是demo/simpleAllocator0.cpp和demo/simpleAllocator0.h</p>
<p>头文件，在这里std::set_new_handler我没有指派函数给他，所以其实allocator::allocate函数的第二个参数暂时不用理会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simpleAllocator0.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SALLOCATOR_0__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SALLOCATOR_0__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA0 &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> T* _allocate(<span class="keyword">ptrdiff_t</span> size, T* hint) &#123;</span><br><span class="line">        <span class="built_in">std</span>::set_new_handler(<span class="number">0</span>);</span><br><span class="line">        T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size*<span class="keyword">sizeof</span>(T))));</span><br><span class="line">        <span class="keyword">if</span>(!tmp) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of mem"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _deallocate(T* buffer) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _construct(T1* p, <span class="keyword">const</span> T2&amp; val) &#123;</span><br><span class="line">        <span class="keyword">new</span>(p) T1(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _destroy(T* p) &#123;</span><br><span class="line">        p-&gt;~T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">            <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* hint = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span> </span>&#123;</span><br><span class="line">            _deallocate(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">            _construct(p, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;</span><br><span class="line">            _destroy(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (const_pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size_type(UINT_MAX/<span class="keyword">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// end of class allocator</span></span><br><span class="line">&#125; <span class="comment">// end of namespace SA0;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>测试文件simpleAllocator0.cpp，申明一个vector，并且指派自己写的Allocator作为空间适配器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SA0::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia, ia+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"simpleAllocator0.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SA0::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia, ia+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./simpleAllocator0 </span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2 id="具备次配置力-sub-allocation-的-SGI-空间配置器"><a href="#具备次配置力-sub-allocation-的-SGI-空间配置器" class="headerlink" title="具备次配置力( sub-allocation)的 SGI 空间配置器"></a>具备次配置力( sub-allocation)的 SGI 空间配置器</h2><p>由于《STL源码剖析》这本书解读的是SGI版本的STL设计实现，所以我们需要看一些有关方面的特殊实现方法，SGI STL 的配置器与众不同 , 也与标准规范不同 , 其 名 称 是alloc而非allocator,而且不接受任何自变量。换句话说如果你要在程序中明白采用SGI配置器,不能采用标准写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt; iv;<span class="comment">//in VC or CB</span></span><br></pre></td></tr></table></figure>
<p>必须这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::alloc&gt; iv;  <span class="comment">// in GCC</span></span><br></pre></td></tr></table></figure>
<h3 id="SGI-标准的空间配置器-标准的空间配置器-std-allocator"><a href="#SGI-标准的空间配置器-标准的空间配置器-std-allocator" class="headerlink" title="SGI 标准的空间配置器, 标准的空间配置器, std::allocator"></a>SGI 标准的空间配置器, 标准的空间配置器, std::allocator</h3><p>虽然 SGI 也定义有一个符合部份标准、名为allocator的配置器,但SGI自己从未用过它,也不建议我们使用。主要原因是效率不彰,只把 C++的::operator new和::operator delete做一层薄薄的包装而已。下 面是SGI的std::allocator 全貌：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们不赞成含入此文件。这是原始的 HP default allocator。提供它只是为了</span></span><br><span class="line"><span class="comment">//回溯相容。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DO NOT USE THIS FILE 不要使用这个文件,除非你手上的容器是以旧式作法</span></span><br><span class="line"><span class="comment">//完成—那就需要一个拥有 HP-style interface的空间配置器。SGI STL使用</span></span><br><span class="line"><span class="comment">//不同的 allocator界面。SGI-style allocators 不带有任何与对象型别相关</span></span><br><span class="line"><span class="comment">//的参数;它们只回应 void*指标(侯捷注:如果是标准接口,就会响应一个</span></span><br><span class="line"><span class="comment">//「指向对象型别」的指针,T*)。此文件并不含入于其它任何 SGI STL头文件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    set_new_handler(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size * <span class="keyword">sizeof</span>(T))));</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>) &#123;</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> ::allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p)</span> </span>&#123; ::deallocate(p); &#125;</span><br><span class="line">    <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123; <span class="keyword">return</span> (pointer)&amp;x; &#125;</span><br><span class="line">    <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">init_page_size</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(<span class="number">4096</span>/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(UINT_MAX/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本(specialization)。注意,为什么最前面不需加template&lt;&gt;?</span></span><br><span class="line"><span class="comment">//见 1.9.1 节的组态测试。注意,只适用于 GCC。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的两行注释是候捷写的，我自己测了不行，还是要按照标准来</span></span><br><span class="line"><span class="comment">// 然而事实上，我使用gcc8.2.0测试，这条是通不过的，还是需要加上template&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in gcc 8.2.0</span></span><br><span class="line"><span class="comment">// template&lt;&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span>&lt;void&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SGI特殊的空间配置器std-alloc"><a href="#SGI特殊的空间配置器std-alloc" class="headerlink" title="SGI特殊的空间配置器std::alloc"></a>SGI特殊的空间配置器std::alloc</h3><p>上一次所写到，也就是SGI中的Allocator只是对于::operator delete和::operator new的一个简单的包装，并没有任何效率上的优化，其在文档中也不建议我们來直接使用这个allocator</p>
<p>一般的，我们使用C++来构建对象的过程是如下的一个过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> demo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo* pfoo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">delete</span> pfoo;</span><br></pre></td></tr></table></figure>
<p>这其中的new算式内包含两个阶段的动作：</p>
<ol>
<li>call ::operator new配置内存</li>
<li>call Foo::Foo()函数来构建对象内容</li>
</ol>
<p>delete语句内也包含了两个动作</p>
<ol>
<li>call Foo::~Foo()函数析构对象</li>
<li>call ::operator delete来释放内存</li>
</ol>
<p>STL的标准告诉我们，配置器的定义在”memory”这个头文件中，在SGI版本的memory有包含两个文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt; // 负责空间的分配和释放</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt; // 负责内容的构建和析构</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stl_uninitialized.h&gt; 这个之后再说</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这里定义有一些全域函式,用来充填(fill)</span></span><br><span class="line"><span class="comment">	或复制(copy)大块内存内容,它们也都</span></span><br><span class="line"><span class="comment">	隶属于 STL 标准规范:</span></span><br><span class="line"><span class="comment">	un_initialized_copy()</span></span><br><span class="line"><span class="comment">	un_initialized_fill()</span></span><br><span class="line"><span class="comment">	un_initialized_fill_n()</span></span><br><span class="line"><span class="comment">    这些函式虽不属于配置器的范畴,但与对象初值</span></span><br><span class="line"><span class="comment">    设定有关,对于容器的大规模元素初值设定很有</span></span><br><span class="line"><span class="comment">    帮助。这些函式对于效率都有面面俱到的考虑,</span></span><br><span class="line"><span class="comment">    最差情况下会呼叫construct(),</span></span><br><span class="line"><span class="comment">    最佳情况则使用C标准函式memmove() 直接进行</span></span><br><span class="line"><span class="comment">    内存内容搬移。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这两个文件分别负责一个对象的出生/消亡的两个步骤，在stl_construct函数中定义了construct()和destroy()这两个基本的函数</p>
<h3 id="构造和析构的基本工具：-construct-和destroy"><a href="#构造和析构的基本工具：-construct-和destroy" class="headerlink" title="构造和析构的基本工具： construct()和destroy()"></a>构造和析构的基本工具： construct()和destroy()</h3><p>我们先看看在&lt;stl_construct.h&gt;中的部分内容</p>
<p>我们以两个模板参数版本的construct()函数为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向__p指向的内存塞入一个用_T1::_T1(const _T2&amp; __val)函数构造的对象</span></span><br><span class="line"><span class="comment">// 这个功能在头文件&lt;new&gt;中有</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">	<span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1(__value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">	_Construct(__p, __value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以迭代取版本和指针版本的destroy函数为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 第一对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">	__pointer-&gt;~_Tp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">	_Destroy(__pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	_Destroy(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	__destroy(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>补充说明：<br>对于某一个对象，如果用户不定义析构函数，而是用系统自带的，则说明，析构函数基本没有什么用（但默认会被调用）我们称之为trivial destructor。反之，如果特定定义了析构函数，则说明需要在释放空间之前做一些事情，则这个析构函数称为non-trivial destructor。如果某个类中只有基本类型的话是没有必要调用析构函数的，delelte p的时候基本不会产生析构代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对于具有trivial析构函数的对象，不用p-&gt;~T()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span>, _<span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象具有non-trivial析构函数，需要显式的析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    	destroy(&amp;*__first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外的一些对象的destoy函数的特化版，实际上，它们什么都没做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">char</span>*, <span class="keyword">char</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">int</span>*, <span class="keyword">int</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">long</span>*, <span class="keyword">long</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">float</span>*, <span class="keyword">float</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">double</span>*, <span class="keyword">double</span>*) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_HAS_WCHAR_T</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_HAS_WCHAR_T */</span></span></span><br></pre></td></tr></table></figure>
<p>显然的，这些数据经过“摧毁”后，真的消失了吗？并没有，他们还在内存里面，只不过他们所占用的位置被某种方式定为“没有被使用过的”内存区域了（我还没看到书中关于这方面的解释，可能后面会有），这就是为什么我们每次定义一个基本类型的对象，如果未初始化，那么它的值还有上一次销毁的数据的影子，就像“幽灵”一样</p>
<p>又有人要问了，这些函数什么都不做，会不会太不负责任？准备将[first,last) 范围内的所有对象析构掉。我们不知道这个范围有多大,万一很大,而每个物件的解构式都无关痛痒(所谓 trivial-destructor),那么一次次呼叫这些无关痛痒的解构式,对效率有不利影响。因此,这里首先利用value_type()获得迭代器所指物件的型别,再 利 用”type_traits<t>“判 别 该 型 别 的 解 构 式 是 否 无 关 痛 痒 。 若 是true_type,什么也不做就结束;若否false_type,这才以循环方式巡访整个范围,并在循环中每经历一个对象就呼叫第一个版本的 destroy()。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	__destroy(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的想法是很好,但 C++本身并不直接支持对「指标所指之物」的型别判断」，那么VALUE_TYPE(__first)是什么？我们之后再讨论这个问题</p>
<h3 id="空间的配置和释放-std-alloc-in-SGI-STL"><a href="#空间的配置和释放-std-alloc-in-SGI-STL" class="headerlink" title="空间的配置和释放 std::alloc in SGI-STL"></a>空间的配置和释放 std::alloc in SGI-STL</h3><p><strong>注意，我们讨论的是SGI-STL版本，不是标准版本</strong></p>
<p>大致的看完了内存配置后的对象构建行为，和内存对象的析构行为，现在我们来到了内存的分配和释放</p>
<p>对象构建前的空间配置，和对象析构之后的空间回收有stl_alloc.h负责</p>
<p>SGI-STL对此的设计哲学如下：</p>
<ol>
<li>向system heap要更多的空间</li>
<li>更多的考虑多线程的情况（multi-thread）</li>
<li>考虑内存不足的应对</li>
<li>考虑过多「小型区域」的申请造成的内存碎片问题（fragment）</li>
</ol>
<p>为了我和你的小心脏和不聪明的脑袋，我尽量在接下来讨论排除multi-thread状态的情况</p>
<p><strong>台湾程序员把allocator叫配置器，我们这边就按他这么叫吧，嘻嘻</strong></p>
<p>C++ mem分配的基本操作是::operator new(), mem 的释放基本操作是::operator delete()。这两个全局函数相当于C中的malloc和free()，正是因为此，SGI-STL中使用了malloc和free函数</p>
<p>考虑到「小型区域」的多次分配招成的内存碎片问题，SGI-STL设计了双层级配置器，第一级直接使用了malloc和free，第二级则视情况的不同采用了不同的策略</p>
<p>当分配的内存超过128 Bytes，视为「足够大的内存申请」，便直接调用第一级的配置器，反之，我们认为这个请求是「小内存申请请求」，为了降低额外负担，便采用了复杂的整理方式整理内存池，而不是直接调用第一级的空间配置器</p>
<p>整个设计究竟只开放第一级配置器,或是同时开放第二级配置器,取决USE_MALLOC是否被定义(唔,我们可以轻易测试出来,SGI STL并未定义USE_MALLOC):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc single_client_alloc;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure>
<p>无论alloc被定义为第一级或第二级配置器,SGI还为它再包装一个接口如下,<br>使配置器的接口能够符合 STL规格:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> _<span class="function">Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*) _Alloc::allocate(__n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="keyword">static</span> _<span class="function">Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (_Tp*) _Alloc::allocate(<span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::deallocate(__p, __n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">      </span>&#123; _Alloc::deallocate(__p, <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SGI-STL第一级空间分配器的大致工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span> </span><br><span class="line">	<span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>allocate()成员函数直接使用C-type malloc函数</li>
<li>deallocate()成员函数直接使用C-type free函数</li>
<li>模拟C++中的std::set_new_handler来处理内存不足的情况</li>
</ol>
<p>SGI-STL第二季空间配置器的大致工作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>负责维护16个自由串行表，来维护16种小型内存块的分配，内存池以malloc来获得（调用第一级malloc一个大的内存块），如果申请的内存池不足，呼叫调用第一级适配器以获得更大的内存池</li>
<li>如果申请的内存大于128bytes那么直接调用第一级空间配置器</li>
</ol>
<h3 id="第一级适配器-malloc-alloc-template-解析"><a href="#第一级适配器-malloc-alloc-template-解析" class="headerlink" title="第一级适配器 malloc_alloc_template 解析"></a>第一级适配器 malloc_alloc_template 解析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THROW_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> __THROW_BAD_ALLOC fprintf(stderr, <span class="meta-string">"out of memory\n"</span>); exit(1)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span> <span class="comment">/* Standard conforming out-of-memory handling */</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> __THROW_BAD_ALLOC throw std::bad_alloc()</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>类的定义（这里用的直接是SGI_STL的源码，代码风格就是这样有很多下划线）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 一般而言，是thread-safe的</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当没有足够的内存的时候的处理函数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个简单的函数指针 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 非常直接，直接申请空间，出错交给oom_handler处理</span></span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 对free的简单包装</span></span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 同allocate的处理方式  </span></span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下模拟 C++的 set_new_handler(). 换句话说，你可以透过它，</span></span><br><span class="line">  <span class="comment">//指定你自己的 out-of-memory handler</span></span><br><span class="line">  <span class="comment">// 这段代码看不懂的可以看看这个分析</span></span><br><span class="line">  <span class="comment">// https://glemontree.github.io/2017/10/23/[C++]%20static%20void%20(%20__set_malloc_handler(void%20(__f)()))()/</span></span><br><span class="line">  <span class="comment">// 拆开一层一层的分析，最内部的__f是一个函数指针，其参数为void，返回值为void。</span></span><br><span class="line">  <span class="comment">// 对于__set_malloc_handler，首先它是一个函数，其参数为形如__f的函数指针，其返回值也是一个指针，这个指针的类型是void(*)()</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">( * __set_malloc_handler( <span class="keyword">void</span> (*__f)() ) )</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于初始out-of-mem handler的设置，直接设置为nullptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 不断的配置，知道分配到新的内存为止</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化__inst = 0的情况 __malloc_alloc_template&lt;0&gt;为malloc_alloc;</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>
<p>第一级空间分配器以，malloc，free，realloc等C函数执行实际的内存的分配，释放重释放过程。并且作出类似std::set_new_handler()的机制，而不是实际调用C++ std::set_new_handler()组件，因为SGI-STL并没有使用::operator new和::opertor delete来分配和释放内存。</p>
<p>所谓 C++ new handler 机制是,你可以要求系统在内存配置需求无法被满足时,<br>唤起一个你所指定的函式。换句话说一旦::operator new无法达成任务,在丢出去std::bad_alloc异常状态之前，会先调用程序员指定的out_of_mem_handler函数，这个可以由程序员自己编写。</p>
<p>为什么SGI_STL不采用C++标准的::operator new()和::operator delete()作为分配和释放内存的原子操作呢？个人认为可能有以下两点原因：</p>
<ol>
<li>C++ 并没有提供一个类似于realloc的一个充分配动作</li>
<li>一些历史因素</li>
</ol>
<p>所以SGI_STL不使用::operator new和delete，连带的，也就不能使用std::set_new_handler这个组件来对应处理内存不够的情况，为此，SGI-STL的作者自己实现了一个类似的机制</p>
<p>需要注意的是，SGI-STL的第一级空间分配器allocate和reallocate都是在malloc和realloc两个C-type函数不成功以后才会调用S_oom_alloc和S_oom_realloc这两个函数，这两个函数有一个内循环会不停的尝试申请新的内存，知道成功为止，但是当程序员并没有设置malloc_alloc_oom_handle这个函数指针，那么，THROW_BAD_ALLOC就会被执行（这个宏具体就是抛出异常并exit当前进程）</p>
<p>设计内存不足的时候的处理程序是使用者程序员的责任，据说解决这个问题有一套特定的模式，这里就不再细究了。</p>
<h3 id="第二级空间分配器"><a href="#第二级空间分配器" class="headerlink" title="第二级空间分配器"></a>第二级空间分配器</h3><p>第二级空间分配器相比第一级简陋的分配器，有了许多的机制和判断逻辑。小区域动态内存的申请带来的不仅仅是内存碎片的问题，分配的时候，每一片内存的额外负担也是一个很大的问题，毕竟系统要靠这个来管理内存，先前我们提到，很多情况下内存在数据中并没有消失，只是被以某种形式记录为“未被使用的”，假设我们要给一个指针pa申请一块动态的内存空间，那么在pa = new object()，执行之后pa所指的内存空间存在着一个object()默认构造函数构造过的对象，但是在pa - (cookie_size)所指向的空间中存在一个用来记录pa大小和是否被使用的记录数据块（cookie），这也就是说每次申请x bytes内存，<strong>实际上就有x + cookie_size bytes的内存被申请</strong>，这也就意味着，x越小，内存的利用效率越低</p>
<p>而SGI-STL的第二级分配器做法是，如果区域足够大，超过了128bytes,那么就移交给第一级适配器，当申请的内存区域小于128bytes时，则使用内存池（memory pool）来管理这些小的内存块，这种方法又被称为sub-allocation：</p>
<ul>
<li>每次都分配一块很大的内存区域，并且使用空闲列表free_list来管理</li>
<li>如果用户有小区域内存的需求，直接从free_list中找到空闲的结点（空闲的块，有点像文件系统中datanode）</li>
<li>如果用户释放小型内存区域，则直接将这块大小的内存并入free_list链表</li>
<li><strong>需要注意的是，在这种机制下无论分配还是释放，free_list都会把申请的内存区域整理为8 bytes的整数倍（打个比方，用户申请30bytes的内存空间，那么allocator会充free_list_32bytes_sz中分配一个32bytes的可用内存给用户，用户如果释放30bytes内存，那么allocator会强行把后面附加的2bytes也一并回收）</strong>，allocator维护16个free_list链表，分别负责8,16,24,32,40,48 … 128 bytes的内存分配和释放，free_list类似结构如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> free_list_node_bytes &#123;</span><br><span class="line">    <span class="keyword">union</span> free_list_node_bytes* next;</span><br><span class="line">    <span class="keyword">char</span> data_area[SIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于C-type代码足够的灵活，使用union我们不用担心指针的额外开销，这么骚的操作你在Java这种强类型语言中是绝对看不到的233</p>
<p>下面，让我们来康康第二级SGI-STL空间配置器大致的实现吧，由于我个人认为书中的代码相比其实际代码可读性（主要是原代码宏还有下划线太多啦，还涉及到一些多线程方面的情况）更好并且原理上是一样的，这里直接贴书上的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;<span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;<span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="comment">//free-lists个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是第二级配置器。</span></span><br><span class="line"><span class="comment">//注意,无「template 型别参数」,且第二参数完全没派上用场。</span></span><br><span class="line"><span class="comment">//第一参数用于多绪环境下。本书不讨论多绪环境。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> ints&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">defaut_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// ROUND_UP函数把bytes上调至8的整数倍</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 要好好复习一下单目运算	</span></span><br><span class="line">		<span class="comment">// new_bytes = 8n + x + 7 &amp; 7</span></span><br><span class="line">		<span class="comment">// if x == 0 new_bytes = 8n</span></span><br><span class="line">		<span class="comment">// else if x &gt; 0 then x + 7 &gt;= 8 产生进位故(8n + x + 7 &amp; 7) == (8n + 8)</span></span><br><span class="line">		<span class="keyword">return</span> (((bytes) + __ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)__ALIGN - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj* free_list_link;</span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// volatile不知道什么意思的请使用Google搜索</span></span><br><span class="line">	<span class="comment">// 或看看这篇博客：https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html</span></span><br><span class="line">	<span class="comment">// 16个free list</span></span><br><span class="line">	<span class="keyword">static</span> obj* <span class="keyword">volatile</span> free_list[____NFREELISTS];</span><br><span class="line">	<span class="comment">// 下面根据函数区块大小，决定使用第N个free_list;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// eg: 8 + 7 = 15, 15 / 8 = 1, 1 - 1 = 0</span></span><br><span class="line">		<span class="comment">// 这是程序员经常使用的一条数学式子</span></span><br><span class="line">		<span class="keyword">return</span> (((bytes) +__ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 传回一个大小是N的对象，并可能加入大小为n的其他区块到free_list</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分配一个大块空间可容纳 nobjs 个大小为 "size" 的区块。</span></span><br><span class="line">	<span class="comment">// 如果配置 nobjs个区块有所不便,nobjs可能会降低。</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Chunk allocation state.</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* start_free;<span class="comment">//记忆池起始位置。只在 chunk_alloc()中变化</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* end_free;<span class="comment">//记忆池结束位置。只在 chunk_alloc()中变化</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="comment">/* 之后再讨论 */</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span> </span>&#123; <span class="comment">/* 之后再讨论 */</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能初始化的时候这么干</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, <span class="keyword">bool</span>&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, <span class="keyword">bool</span>&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] = </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="空间分配函数allocator"><a href="#空间分配函数allocator" class="headerlink" title="空间分配函数allocator()"></a>空间分配函数allocator()</h4><p>身为一个空间分配器，default_alloc_template拥有分配器的标准接口allocate()。这个函数首先判断申请的内存区域的大小，大于128bytes会调用第一级空间分配器，否则就检查对应的free_list，如果free_list有空闲的区块，那么直接分配空闲区块，如果没有足够的空闲区块，则调整区块大小至8的倍数，然后调用本类内的refill函数，重新为free_list填充足够的内存空间</p>
<p>在default_alloc_template类内<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这是一个二级指针</span></span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj* result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大于128bytes则直接调用第一级的空间分配器</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找16个free_list中合适的那一个</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        <span class="comment">// 没有找到可用的free_list</span></span><br><span class="line">        <span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配完free_list结点之后</span></span><br><span class="line">    *my_free_list = result-&gt;free_list_link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空间释放器deallocator"><a href="#空间释放器deallocator" class="headerlink" title="空间释放器deallocator()"></a>空间释放器deallocator()</h4><p>default_alloc_template拥有便准的deallocate()。这个函数首先判断处理的内存区块的大小，大于128 bytes就呼叫第一级的空间释放器，小于128bytes就找出对应的free_list，并且将区块回收</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p != nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    obj* q = (obj* ) p;</span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::deallocate(p, n);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找对应的free_list</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整free_list</span></span><br><span class="line">    q -&gt; free_list_link = *my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收区块</span></span><br><span class="line">    *my_free_list = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重新填充free-list-refill"><a href="#重新填充free-list-refill" class="headerlink" title="重新填充free_list: refill"></a>重新填充free_list: refill</h4><p>我们之前讨论过的，就是当申请内存的时候，当free_list不够用的时候，当它发现free_list就调用refill()准备为free_list重新填充空间。新的空间将取自内存池，内存池的申请由chunk_alloc来完成。预设取得20个新结点，但是万一内存池空间不足获得的结点数可能要小于20</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传回一个大小是n的对象，并且有时候会为free_list填充适当的结点</span></span><br><span class="line"><span class="comment">// 我们假设n已经上调至8的整数倍</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> ints&gt;</span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, ints&gt;::refill(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 调用chunk_alloc()，取得nobjs个区块作为free_list的新结点</span></span><br><span class="line">    <span class="comment">// 值得注意的是nobjs是一个引用传值参数</span></span><br><span class="line">    <span class="keyword">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">    obj* result;</span><br><span class="line">    obj* current_obj;</span><br><span class="line">    obj* next_obj;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果只获得一个区块，这个区块就拨给调用者使用free_list并没有增加任何新的结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则准备调整free_list，纳入新的结点</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下在chunk空间内建立free_list</span></span><br><span class="line">    result = (obj*)chunk;</span><br><span class="line">    </span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下free_list各个结点串接起来</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; ;++i) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj*)((<span class="keyword">char</span>*) next_obj + n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存池分配chunk-alloc"><a href="#内存池分配chunk-alloc" class="headerlink" title="内存池分配chunk_alloc"></a>内存池分配chunk_alloc</h4><p>从内存池中取得新的空闲空间给free list使用，这是chunk_alloc的职责：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设size已经上调至8的整数倍</span></span><br><span class="line"><span class="comment">// nobjs是一个引用参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size*nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line">    <span class="keyword">if</span>(bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        <span class="comment">// 当内存池的容量还满足需求的时候</span></span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// 当内存池的空间不够,但是能够供应一个以上的size空间的时候</span></span><br><span class="line">        nobjs = bytes_left / size;</span><br><span class="line">        total_bytes = size*nobjs;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当内存池剩余空间连一个块都无法提供的时候</span></span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span>*total_bytes + (ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 以下操作试图利用残余的小内存池空间</span></span><br><span class="line">        <span class="keyword">if</span>(bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 内存池中还有一些零头</span></span><br><span class="line">            <span class="comment">// 我在这里卡了一会，因为无法理解如果内存池内剩余的空间不足8bytes的情况下这么写怎么会行的通，后来我想通了。</span></span><br><span class="line">            <span class="comment">// 因为无论是内存池的申请还是使用，都是以8bytes的整数倍为单位进行的，当还有剩余空间的时候，它必然是8bytes的整数倍，这句if语句你可以理解为if(bytes_letft &gt;0 &amp;&amp; bytes_left &gt;= 8)</span></span><br><span class="line">            obj* <span class="keyword">volatile</span>* my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">            ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">            *my_free_list = (obj*)start_free;</span><br><span class="line">        &#125; <span class="comment">// end if</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置Heap空间</span></span><br><span class="line">        start_free = (<span class="keyword">char</span>* )<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == start_free) &#123;</span><br><span class="line">            <span class="comment">// heap空间不足,malloc失败</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">            obj *p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试检查我们手头拥有的东西</span></span><br><span class="line">            <span class="comment">// 我们不打算分配较小的内存块，因为那在多进程机器上容易造成灾难性的后果</span></span><br><span class="line">            <span class="comment">// 搜索适当的free_list</span></span><br><span class="line">            <span class="comment">// 所谓适当是指「还有没有使用的区块，且区块够大」的free_list</span></span><br><span class="line">            <span class="keyword">for</span>(i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">                p = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != p) &#123;</span><br><span class="line">                    <span class="comment">// 这个free_list还有空闲的区块</span></span><br><span class="line">                    *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                    start_free = (<span class="keyword">char</span>*) p;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 递归调用自己来修正nobjs</span></span><br><span class="line">                    <span class="keyword">return</span> chunk(size, nobjs);</span><br><span class="line">                &#125; <span class="comment">// end if</span></span><br><span class="line">            &#125; <span class="comment">// end for</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果经过上面的挣扎还没有办法得到内存并return退出函数</span></span><br><span class="line">            <span class="comment">// 只能调用第一级内存分配器了，因为第一级分配器函数有out-of-memory处理机制（之前提到的）</span></span><br><span class="line">            end_free = <span class="number">0</span>;</span><br><span class="line">            start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">        &#125; <span class="comment">// end of if(0 == start_free)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可喜可贺，如果malloc成功了，你可以不用理会那么多</span></span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + heap_size;</span><br><span class="line">        <span class="comment">// 递归调用自己以修正nobjs</span></span><br><span class="line">        <span class="keyword">return</span> chunk_alloc(size, nobjs);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// end if...else if ... else ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数看得我心情澎湃，居然代码还可以这么写</p>
<p>我们简单的总结一下，chunk_alloc它具体都作了一些什么</p>
<ul>
<li>判断内存池的剩余空间end_free - start_free<ul>
<li>如果有足够的剩余空间给20个size使用，那么直接划拨给用户20个size的chunk</li>
<li>不够20个的，但至少能够分配一个的，能分配几个就分配几个size的区块</li>
<li>内存池连一个size都拿不出来，穷得叮当响，那么把剩余内存池空间放入free_list（由于内存池无论是是申请还是使用都是8bytes的整数倍为单位进行操作的，所以剩余的空间一定是8bytes的整数倍，可以直接放入free_list），这种情况下我们再进行以下动作<ul>
<li>直接用malloc申请一个新的内存池<ul>
<li>申请成功，以新的内存池为基础，递归调用自己并返回修正nobjs</li>
<li>申请失败，寻找是否有剩余的free_list空间，要求他把吃掉的内存吐出来，如果这样还是找不到合适的内存，那么万念俱灰，变成咸鱼（把事情推给别人去做），交给第一级分配器去处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义了五个全局函数，作用在未初始化的内存空间中，这样的功能呢个对于容器的实际构造很有帮助。我们看到除了之前提到过得construct和destroy函数之外，还有三个用来使用大段内存初始化容器的函数，分别是uninitialized_copy(), uninitialized_fill(), uninitialized_fill_n()，分别对应于高阶函数copy，fill，fill_n。你在实际使用中应该包含在”memory”头文件中，不过我们本地保存的SGI-STL代码把他们的实现放到了stl_uninitialized</p>
<h3 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) ;</span></span><br></pre></td></tr></table></figure>
<p>uninitialized_copy() 使我们能够将内存的配置与对象的构造行为分离开，如果作为输出目的地 [result, result + (last - first)) 左闭右开范围内的每一个迭代器都指向一个未经过初始化或者构造的对象区域，则uninitialized_copy函数会使用复制构造函数，分别以[first, last)左闭右开区间内的每一个对象复制构造到result所指的区间内。,针对输入范围内的每一个迭代器 i,此函式会调用construct(&amp;<em>(result+(i-first)),</em>i) ,产生*i的复制品,放置于输出范围的相对位置上。</p>
<p>C++标准要求uninitialized_copy的行为是：</p>
<ul>
<li>如果所有的复制构造函数都成功运行，那么构造成功</li>
<li>如果其中有一个失败了，你不仅不能继续构建下去，甚至还要想办法回退(rollback)</li>
</ul>
<h3 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ForwardIterator, class T&gt;</span><br><span class="line">void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T&amp; x);</span><br></pre></td></tr></table></figure>
<p>行为：</p>
<ul>
<li>在 [first, last) 区间为每一个对象使用x作为引用参数调用赋值构造函数</li>
<li>不成功就回退，这点和uninitialized_copy有点类似</li>
</ul>
<p>uninitialized_copy()和uninitialized_fill()必须具备”commit or rollback”语意,换句话说它要不就产生出所有必要元素,要不就不产生任何元素。<br>如果有任何一个copy constructor丢出异常(exception),uninitialized_fill()<br>必须能够将已产生之所有元素解构掉。</p>
<h3 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>);</span></span><br></pre></td></tr></table></figure>
<p>行为：</p>
<ul>
<li>和uninitialized_fill本质上意思是一样的，只不过区间的表达方法不一样</li>
<li>也具有commit-or-rollback语义特性</li>
</ul>
<p>具体实现之后放出，它们依赖于一种叫做POD（plain old data）的布尔模板参数来判断函数泛化后的不同实现</p>
<p>所谓POD，我说的直白一点，就是C-type的struct类似的类,它的每一个成员变量都是紧贴在一起的且没有别的“杂质”字节，比如虚指针和函数指针什么的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> <span class="title">tmp</span> = (<span class="title">struct</span> <span class="title">Tmp</span>)&#123;</span><span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;; <span class="comment">// 这样初始化可行</span></span><br><span class="line"><span class="keyword">char</span>* p = ((<span class="keyword">char</span>*)&amp;tmp) + <span class="number">2</span>;</span><br><span class="line">*p == <span class="string">'c'</span>; <span class="comment">// true</span></span><br><span class="line">*p = <span class="string">'k'</span>;</span><br><span class="line">tmp.c == k; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>struct Tmp就是POD类型的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以fill_n版本的实现为例</span></span><br><span class="line"><span class="comment">// 第三级调用POD版本，直接调用高阶函数fill_n</span></span><br><span class="line"><span class="comment">// fill_n和其他两个高阶函数，我们以后会讨论</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 当__x是POD直接调用fill_n</span></span><br><span class="line">  <span class="keyword">return</span> fill_n(__first, __n, __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三级调用非POD形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __cur = __first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="comment">// 当__x并不是POD的时候，老老实实的调用构造函数来复制</span></span><br><span class="line">    <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__cur)</span><br><span class="line">      _Construct(&amp;*__cur, __x);</span><br><span class="line">    <span class="keyword">return</span> __cur;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 你好，你有成员构造函数执行失败了，请回滚</span></span><br><span class="line">  __STL_UNWIND(_Destroy(__first, __cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二级调用在这里发生</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Tp1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, _<span class="title">Tp1</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里才是入口哦,第一级调用在这里发生</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></span><br><span class="line"><span class="class"><span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>) &#123;</span></span><br><span class="line">	<span class="keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现：又出现了，那个玄学value_type()，还有is_pod判定函数，这个要到书的后面才会讲实现原理。</p>
<ul>
<li>用户调用uninitialized_fill_n</li>
<li>uninitialized_fill_n 调用 __uninitialized_fill_n</li>
<li><strong>uninitialized_fill_n 调用 </strong>uninitialized_fill_n_aux</li>
<li>__uninitialized_fill_n_aux根据复制来源是否是POD来选择显式的调用构造函数并且显式的回滚，还是直接调用fill_n来填充内存</li>
</ul>
<p>而至于没有讲到的uninitialized_copy和uninitialized_fill，大致的行为都是类似的</p>
<p>至此我们这一个章节暂时告一段落，永远不要停止学习！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/26/stl_analysis0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/26/stl_analysis0/" class="post-title-link" itemprop="url">关于STL代码学习和实践(0)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-26 22:20:47" itemprop="dateCreated datePublished" datetime="2018-11-26T22:20:47+08:00">2018-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="准备开一个学习STL代码并且自己实现的新坑啦！"><a href="#准备开一个学习STL代码并且自己实现的新坑啦！" class="headerlink" title="准备开一个学习STL代码并且自己实现的新坑啦！"></a>准备开一个学习STL代码并且自己实现的新坑啦！</h1><p>STL的有些内部实现还是很值得学习的，而且学会如何造一些比较基础的轮子也对进一步加深对自己所学知识的理解也是很有好处的</p>
<p>参考书籍是《STL源码剖析》，候捷写的，听说这本写的不错，同时我会借鉴一些Github上已经有人写出来的 <a href="https://github.com/zouxiaohang/TinySTL" title="微型版本" target="_blank" rel="noopener">微型版本</a> 来加深我对于这些源代码的理解</p>
<p>再加上我自己从网上搞到一份SGI-STL的实现版本（V3.3），撸起袖子，开干</p>
<h1 id="从stl-config-h出发"><a href="#从stl-config-h出发" class="headerlink" title="从stl_config.h出发"></a>从stl_config.h出发</h1><p>这个代码很长，但是大部分都是考虑到不同编译器的不同的性质方面的支持来设置的，用来加强这些代码的可移植性。但是这一节的宏定义太多了，看的我头皮发麻。</p>
<p>那么它都作了一些什么呢</p>
<ol>
<li>如果编译器并不支持bool类型（也就是没有这个内建类型），那么定义  “STL_NO_BOOL” 和 “STL_DONT_USE_BOOL_TYPEDEF”等宏</li>
<li><p>如果编译器的标准链接库᳾支持 drand48()函式，就定定义”STL_NO_DRAND48”，这个drand48()是什么呢？drand48 返回服从均匀分布的·[0.0, 1.0) 之间的 double 型随机数。哇，好强阿，那么大致实现方法是怎么样的呢（这里不再细究防止跑题，以后有时间再开坑研究一下）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">drand48</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </span><br><span class="line">    seed = (<span class="number">0x5DEECE66D</span>LL * <span class="number">1</span> + <span class="number">0xB16</span>) &amp; <span class="number">0xFFFFFFFFFFFF</span>LL; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x = seed &gt;&gt; <span class="number">16</span>;  </span><br><span class="line">    <span class="keyword">return</span>  ((<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="number">0x100000000</span>LL);  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果编译器无法处理 static members of template classes，就定义STL_STATIC_TEMPLATE_MEMBER_BUG</p>
</li>
<li>如果编译器᳾支持关键词 typename，就将’typename’定义为一个 null macro. </li>
<li>如果编译器支持 partial specialization of class templates，就定义“STL_CLASS_PARTIAL_SPECIALIZATION”，这是啥意思呢，根据cplusplusrefence网站的实例，大致如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> &#123;</span>&#125;;            <span class="comment">// primary template</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;T, T*, I&gt; &#123;</span>&#125;;  <span class="comment">// #1: partial specialization where T2 is a pointer to T1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;T*, T2, I&gt; &#123;</span>&#125;; <span class="comment">// #2: partial specialization where T1 is a pointer</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;int, T*, 5&gt; &#123;</span>&#125;; <span class="comment">// #3: partial specialization where T1 is int, I is 5,</span></span><br><span class="line">                        <span class="comment">//     and T2 is a pointer</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">X</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;X, T*, I&gt; &#123;</span>&#125;;   <span class="comment">// #4: partial specialization where T2 is a pointer</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们大部分情况下会使用第一种情况，其他情况（特殊的）都被称之为partial specialization，根据我的理解，就是一层模板套上一层带有模板的成员，用来特化基础形态的（其中）一些模板成员，完全特化就是所有的模板参数都被指定</p>
<ol start="6">
<li>如果编译器支持 partial ordering of function templates（亦称为partial specialization of function templates），就定义STL_FUNCTION_TMPL_PARTIAL_ORDER，这个是函数版本的，大致意思是和第六点类似的</li>
<li>如果编译器允许我们在呼叫一个 function template时可以明白指定其template arguments，就定义STL_EXPLICIT_FUNCTION_TMPL_ARGS</li>
<li>如果编译器支持 template members of classes，就定义STL_MEMBER_TEMPLATES</li>
<li>如果编译器不支持关键词 explicit，就定义’explicit’为一个 null macro</li>
<li>如果编译器无法根据前一个 template parameters设定下一个 template parameters 的默认值，就定义STL_LIMITED_DEFAULT_TEMPLATES</li>
<li>如果编译器针对 non-type template parameters 执行 function template 的自变量推导（argument deduction）时有问题，就定义STL_NON_TYPE_TMPL_PARAM_BUG</li>
<li>如果编译器无法支持迭代器的 operator-&gt;，就定义SGI_STL_NO_ARROW_OPERATOR</li>
<li>如果编译器（在你所选择的模式中）支持 exceptions，就定义STL_USE_EXCEPTIONS</li>
<li>定义STL_USE_NAMESPACES 可使我们自动获得 using std::list;之类的叙句</li>
<li>如果ᴀ链接库由 SGI编译器来编译，而且使用者并未选择 pthreads，或其它 threads，就定义STL_SGI_THREADS.</li>
<li>如果A链接库由一个 WIN32 编译器编译，并且在多绪模式下，就定义STL_WIN32THREADS</li>
<li>适当地定义与 namespace相关的 macros 如STD,STL_BEGIN_NAMESPACE</li>
<li>适当地定义 exception 相关的 macros 如 STL_TRY, STL_UNWIND</li>
<li>根据STL_ASSERTIONS是否定义，将 stl_assert 定义为一个测试动作或一个 null macro</li>
</ol>
<h1 id="stl-config-h全文"><a href="#stl-config-h全文" class="headerlink" title="stl_config.h全文"></a>stl_config.h全文</h1><p>省略了前面的一些注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_CONFIG_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_PTHREADS) &amp;&amp; !defined(_NOTHREADS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PTHREADS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_UITHREADS) &amp;&amp; !defined(_PTHREADS) &amp;&amp; !defined(_NOTHREADS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_UITHREADS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;standards.h&gt;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_BOOL)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BOOL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM == _ABIO32</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_STATIC_CONST_INIT_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_WCHAR_T_IS_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_WCHAR_T </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_TYPENAME_IS_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 730) &amp;&amp; defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM != _ABIO32</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_MEMBER_TEMPLATE_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 730) &amp;&amp; defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM != _ABIO32</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> COMPILER_VERSION &lt; 720 || (defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM == _ABIO32)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &lt; 721) || \</span></span><br><span class="line">    !defined(__STL_HAS_NAMESPACES) || defined(__STL_NO_NAMESPACES)</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &lt; 730 || !defined(_STANDARD_C_PLUS_PLUS) || \</span></span><br><span class="line">      !defined(_NAMESPACES)</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_SGI_THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_LONGLONG) &amp;&amp; defined(_SGIAPI) &amp;&amp; _SGIAPI</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_LONG_LONG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &gt;= 730 &amp;&amp; defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NEW_IOSTREAMS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &gt;= 730 &amp;&amp; defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CAN_THROW_RANGE_ERRORS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &gt;= 730 &amp;&amp; defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __SGI_STL_USE_AUTO_PTR_CONVERSIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jochen Schlick '1999  - added new #defines (__STL)_UITHREADS (for </span></span><br><span class="line"><span class="comment"> *                         providing SCO / Solaris / UI thread support)</span></span><br><span class="line"><span class="comment"> *                       - added the necessary defines for the SCO UDK 7 </span></span><br><span class="line"><span class="comment"> *                         compiler (and its template friend behavior)</span></span><br><span class="line"><span class="comment"> *                       - all UDK7 specific STL changes are based on the </span></span><br><span class="line"><span class="comment"> *                         macro __USLC__ being defined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// SCO UDK 7 compiler (UnixWare 7x, OSR 5, UnixWare 2x)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__USLC__)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_WCHAR_T </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PARTIAL_SPECIALIZATION_SYNTAX</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_LONG_LONG</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">if</span> defined(_REENTRANT)</span></span><br><span class="line"><span class="meta">#           <span class="meta-keyword">define</span> _UITHREADS     <span class="comment">/* if      UnixWare &lt; 7.0.1 */</span></span></span><br><span class="line"><span class="meta">#           <span class="meta-keyword">define</span> __STL_UITHREADS</span></span><br><span class="line"><span class="comment">//   use the following defines instead of the UI threads defines when</span></span><br><span class="line"><span class="comment">//   you want to use POSIX threads</span></span><br><span class="line"><span class="comment">//#         define _PTHREADS      /* only if UnixWare &gt;=7.0.1 */</span></span><br><span class="line"><span class="comment">//#         define __STL_PTHREADS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 7</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ &lt; 2 </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 8</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt;= 8</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CAN_THROW_RANGE_ERRORS</span></span><br><span class="line">      <span class="comment">//    g++ 2.8.1 supports member template functions, but not member</span></span><br><span class="line">      <span class="comment">//    template nested classes.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">if</span> __GNUC_MINOR__ &gt;= 9</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __SGI_STL_USE_AUTO_PTR_CONVERSIONS</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="comment">//#       define __STL_USE_NEW_IOSTREAMS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _REENTRANT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PTHREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (__GNUC__ &lt; 2) || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 95)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_BOOL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _REENTRANT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PTHREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_PARTIAL_SPECIALIZATION_SYNTAX</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__COMO__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Intel compiler, which uses the EDG front end.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__ICL)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_LONG_LONG </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mingw32, egcs compiler using the Microsoft C runtime</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__MINGW32__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cygwin32, egcs compiler on MS Windows</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__CYGWIN__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Microsoft compiler.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_MSC_VER) &amp;&amp; !defined(__ICL) &amp;&amp; !defined(__MWERKS__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_STATIC_CONST_INIT_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_USING_CLAUSE_IN_CLASS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_FRIEND_TEMPLATE_CLASS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &lt; 1100  <span class="comment">/* 1000 is version 4.0, 1100 is 5.0, 1200 is 6.0. */</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BOOL</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &gt; 1000</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">include</span> <span class="meta-string">&lt;yvals.h&gt;</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DONT_USE_BOOL_TYPEDEF</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &gt;= 1200</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PARTIAL_SPECIALIZATION_SYNTAX</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CAN_THROW_RANGE_ERRORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> NOMINMAX</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">undef</span> min</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">undef</span> max</span></span><br><span class="line"><span class="comment">// disable warning 'initializers put in unrecognized initialization area'</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> ( disable : 4075 )</span></span><br><span class="line"><span class="comment">// disable warning 'empty controlled statement found'</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> ( disable : 4390 )</span></span><br><span class="line"><span class="comment">// disable warning 'debug symbol greater than 255 chars'</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> ( disable : 4786 )</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &lt; 1100</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Because of a Microsoft front end bug, we must not provide a</span></span><br><span class="line">    <span class="comment">// namespace qualifier when declaring a friend function.</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_QUALIFIER</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__BORLANDC__)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __BORLANDC__ &gt;= 0x540 <span class="comment">/* C++ Builder 4.0 */</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __MT__</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_NO_BOOL) &amp;&amp; !defined(__STL_DONT_USE_BOOL_TYPEDEF)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> false 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> typename</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEPENDENT_DEFAULT_TMPL(_Tp)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEPENDENT_DEFAULT_TMPL(_Tp) = _Tp</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE template</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> explicit</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NULL_TMPL_ARGS <span class="meta-string">&lt;&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NULL_TMPL_ARGS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \</span></span><br><span class="line">     || defined (__STL_PARTIAL_SPECIALIZATION_SYNTAX)</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL template<span class="meta-string">&lt;&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use standard-conforming allocators if we have the necessary language</span></span><br><span class="line"><span class="comment">// features.  __STL_USE_SGI_ALLOCATORS is a hook so that users can </span></span><br><span class="line"><span class="comment">// disable new-style allocators, and continue to use the same kind of</span></span><br><span class="line"><span class="comment">// allocators as before, without having to edit library headers.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_CLASS_PARTIAL_SPECIALIZATION) &amp;&amp; \</span></span><br><span class="line">     defined(__STL_MEMBER_TEMPLATES) &amp;&amp; \</span><br><span class="line">     defined(__STL_MEMBER_TEMPLATE_CLASSES) &amp;&amp; \</span><br><span class="line">    !defined(__STL_NO_BOOL) &amp;&amp; \</span><br><span class="line">    !defined(__STL_NON_TYPE_TMPL_PARAM_BUG) &amp;&amp; \</span><br><span class="line">    !defined(__STL_LIMITED_DEFAULT_TEMPLATES) &amp;&amp; \</span><br><span class="line">    !defined(__STL_USE_SGI_ALLOCATORS) </span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) allocator<span class="meta-string">&lt; T &gt;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) alloc</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces</span></span><br><span class="line"><span class="comment">// without having to edit library headers.  __STL_NO_RELOPS_NAMESPACE is</span></span><br><span class="line"><span class="comment">// a hook so that users can disable the std::rel_ops namespace, keeping </span></span><br><span class="line"><span class="comment">// the relational operator template in namespace std, without having to </span></span><br><span class="line"><span class="comment">// edit library headers.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_HAS_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD std</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_NAMESPACE namespace std &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_NAMESPACE &#125;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER) &amp;&amp; \</span></span><br><span class="line">       !defined(__STL_NO_RELOPS_NAMESPACE)</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123; namespace rel_ops &#123;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125; &#125;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STD_RELOPS std::rel_ops</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span> <span class="comment">/* Use std::rel_ops namespace */</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STD_RELOPS std</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span> <span class="comment">/* Use std::rel_ops namespace */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">undef</span>  __STL_USE_NAMESPACE_FOR_RELOPS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_RELOPS </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">undef</span>  __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some versions of the EDG front end sometimes require an explicit</span></span><br><span class="line"><span class="comment">// namespace spec where they shouldn't.  This macro facilitates that.</span></span><br><span class="line"><span class="comment">// If the bug becomes irrelevant, then all uses of __STD_QUALIFIER</span></span><br><span class="line"><span class="comment">// should be removed.  The 7.3 beta SGI compiler has this bug, but the</span></span><br><span class="line"><span class="comment">// MR version is not expected to have it.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STD_QUALIFIER)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_QUALIFIER std::</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_QUALIFIER</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TRY try</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CATCH_ALL catch(...)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_THROW(x) throw x</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_RETHROW throw</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NOTHROW throw()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_UNWIND(action) catch(...) &#123; action; throw; &#125;</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TRY </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CATCH_ALL <span class="meta-keyword">if</span> (false)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_THROW(x) </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_RETHROW </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NOTHROW </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_UNWIND(action) </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_ASSERTIONS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __stl_assert(expr) \</span></span><br><span class="line">    <span class="keyword">if</span> (!(expr)) &#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s:%d STL assertion failure: %s\n"</span>, \</span><br><span class="line">			  __FILE__, __LINE__, # expr); <span class="built_in">abort</span>(); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __stl_assert(expr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__STL_WIN32THREADS) || defined(__STL_SGI_THREADS) \</span></span><br><span class="line">    || defined(__STL_PTHREADS)  || defined(__STL_UITHREADS)</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_VOLATILE volatile</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_VOLATILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \</span></span><br><span class="line">    &amp;&amp; defined(__STL_MEMBER_TEMPLATES) \</span><br><span class="line">    &amp;&amp; !defined(_STL_NO_CONCEPT_CHECKS)</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __STL_USE_CONCEPT_CHECKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CONFIG_H */</span></span></span><br></pre></td></tr></table></figure>
<h1 id="测试stl-config-h中的宏选项"><a href="#测试stl-config-h中的宏选项" class="headerlink" title="测试stl_config.h中的宏选项"></a>测试stl_config.h中的宏选项</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>我使用的测试代码在我的github repo中fake_stl/test/const_test0.cpp中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">config_test0</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _PTHREADS</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define __STL_PTHREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__sgi begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_BOOL)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_TYPENAME_IS_KEYWORD)</span></span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _MEMBER_TEMPLATES</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_SGI_THREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__sgi end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// # include &lt;_G_config.h&gt; 在现在我使用的版本的gcc(8.2.1)中这个被弃用了，改用stdio.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_STATIC_TEMPLATE_MEMBER_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_FUNCTION_TMPL_PARTIAL_ORDER"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_EXPLICIT_FUNCTION_TMPL_ARGS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it.</span></span><br><span class="line"><span class="comment">       It should be upgraded to glibc 2.0 or later. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_PTHREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SUNPRO_CC begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SUNPRO_CC end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__COMO__)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__COMO__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__COMO__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"_MSC_VER begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> _MSC_VER &gt; 1000</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"include &lt;yvals.h&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NO_DRAND48"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> _MSC_VER &lt; 1100</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NON_TYPE_TMPL_PARAM_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SGI_STL_NO_ARROW_OPERATOR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_WIN32THREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"_MSC_VER end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__BORLANDC__)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__BORLANDC__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NO_DRAND48"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_LIMITED_DEFAULT_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SGI_STL_NO_ARROW_OPERATOR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NON_TYPE_TMPL_PARAM_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __MT__</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_WIN32THREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__BORLANDC__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_NEED_BOOL)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"typedef int bool;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define true 1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define false 0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_TYPENAME</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define typename"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_EXPLICIT</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define explicit"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NULL_TMPL_ARGS &lt;&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NULL_TMPL_ARGS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TEMPLATE_NULL template&lt;&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TEMPLATE_NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces</span></span><br><span class="line"><span class="comment">// without having to edit library headers.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD std"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_NAMESPACE namespace std &#123;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_NAMESPACE &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACE_FOR_RELOPS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_RELOPS_NAMESPACE namespace std &#123;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_RELOPS_NAMESPACE &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD_RELOPS std"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_NAMESPACES begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACE_FOR_RELOPS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_RELOPS_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_RELOPS_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD_RELOPS "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_NAMESPACES end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TRY try"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CATCH_ALL catch(...)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_RETHROW throw"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NOTHROW throw()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_UNWIND(action) catch(...) &#123; action; throw; &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_EXCEPTIONS begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TRY "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CATCH_ALL if (false)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_RETHROW "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NOTHROW "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_UNWIND(action) "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_EXCEPTIONS end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_ASSERTIONS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__stl_assert(expr) \</span></span><br><span class="line"><span class="string">    if (!(expr)) &#123; fprintf(stderr, \"%s:%d STL assertion failure: %s\n\", \</span></span><br><span class="line"><span class="string">             __FILE__, __LINE__, # expr); abort(); &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__stl_assert(expr)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    config_test0();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码对应的是gcc2.8那个时代，现在很多代码都不对了，所以有关GNUC的那一段判断我进一步作出了细分（精力有限，其他编译器的选项我都没有看，只看了gcc的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// # include &lt;_G_config.h&gt; 在现在我使用的版本的gcc(8.2.1)中这个被弃用了，改用stdio.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_STATIC_TEMPLATE_MEMBER_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_FUNCTION_TMPL_PARTIAL_ORDER"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_EXPLICIT_FUNCTION_TMPL_ARGS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it.</span></span><br><span class="line"><span class="comment">       It should be upgraded to glibc 2.0 or later. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_PTHREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="运行输出结果"><a href="#运行输出结果" class="headerlink" title="运行输出结果"></a>运行输出结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__GNUC__ begin</span><br><span class="line">__STL_USE_EXCEPTIONS</span><br><span class="line">__GNUC__ end</span><br><span class="line"></span><br><span class="line">__STL_NULL_TMPL_ARGS</span><br><span class="line">__STL_TEMPLATE_NULL</span><br><span class="line">! __STL_USE_NAMESPACES begin</span><br><span class="line">__STD </span><br><span class="line">__STL_BEGIN_NAMESPACE </span><br><span class="line">__STL_END_NAMESPACE </span><br><span class="line">__STL_USE_NAMESPACE_FOR_RELOPS</span><br><span class="line">__STL_BEGIN_RELOPS_NAMESPACE </span><br><span class="line">__STL_END_RELOPS_NAMESPACE </span><br><span class="line">__STD_RELOPS </span><br><span class="line">! __STL_USE_NAMESPACES end</span><br><span class="line"></span><br><span class="line">! __STL_USE_EXCEPTIONS begin</span><br><span class="line">__STL_TRY </span><br><span class="line">__STL_CATCH_ALL if (false)</span><br><span class="line">__STL_RETHROW </span><br><span class="line">__STL_NOTHROW </span><br><span class="line">__STL_UNWIND(action) </span><br><span class="line">! __STL_USE_EXCEPTIONS end</span><br><span class="line"></span><br><span class="line">__stl_assert(expr)</span><br></pre></td></tr></table></figure>
<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> lsb_release -a</span><br><span class="line">LSB Version:    1.4</span><br><span class="line">Distributor ID: Arch</span><br><span class="line">Description:    Arch Linux</span><br><span class="line">Release:        rolling</span><br><span class="line">Codename:       n/a</span><br><span class="line"><span class="meta">$</span> gcc --version</span><br><span class="line">gcc (GCC) 8.2.1 20180831</span><br><span class="line">Copyright © 2018 Free Software Foundation, Inc.</span><br><span class="line">本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；</span><br><span class="line">包括没有适销性和某一专用目的下的适用性担保。</span><br><span class="line"><span class="meta">$</span> g++ --version</span><br><span class="line">g++ (GCC) 8.2.1 20180831</span><br><span class="line">Copyright © 2018 Free Software Foundation, Inc.</span><br><span class="line">本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；</span><br><span class="line">包括没有适销性和某一专用目的下的适用性担保。</span><br></pre></td></tr></table></figure>
<p>由此来看，gcc的能力十分强悍，很多轮子不需要自己造</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/25/redis-0-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/25/redis-0-md/" class="post-title-link" itemprop="url">redis(0):the installation and test of redis utils</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-25 03:56:25" itemprop="dateCreated datePublished" datetime="2018-11-25T03:56:25+08:00">2018-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux下C-操作redis入门配置和测试"><a href="#Linux下C-操作redis入门配置和测试" class="headerlink" title="Linux下C++操作redis入门配置和测试"></a>Linux下C++操作redis入门配置和测试</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Redis、Key-Value数据库，并提供多种语言的API。基于内存这一点特性使得它速度很快，在实际项目中常用来作为缓存，队列，数据库来使用。</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>x86_64 Linux 4.19.2-arch1-1-ARCH</li>
</ul>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ul>
<li><p>第一步，安装redis数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，运行redis.service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你不知道redis进程所用的端口，你可以查看/etc/redis.conf文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redis.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者查看进程占用端口情况,一般默认的是6379</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，你可以下载可用的接口和源代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/redis/hiredis</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进入文件夹并进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hiredis</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样你会得到一个动态链接库文件(.so)</p>
</li>
<li><p>你在使用这些接口的时候，你可以在和hiredis同级的文件夹中的cpp文件写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include "hiredis/hiredis.h"</span><br></pre></td></tr></table></figure>
</li>
<li><p>之前看到网上有博客写要加extern “C”,但是我看一下hiredis.h头文件,作者已经考虑到C++的使用问题，所以其实可以不加</p>
</li>
<li><p>假设你在和hiredis同级的文件夹下要编译的文件名为redis_test.cpp, 那么你编译的时候应该记得链接上libhiredis.so</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ redis_test.cpp hiredis/libhiredis.so -o redis_test.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>你还可以手动建立/usr/include/hiredis 和/usr/lib/hiredis文件夹，然后分别把hiredis.h和libhiredis.so移动到二者下面</p>
</li>
<li><p>这样的话当前版本的hiredis接口就是全局可用的，但是每次编译的时候貌似还是要带上”-lhiredis”参数</p>
</li>
<li><p>在Archlinux中，你可以用pacman直接安装hiredis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S hiredis</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后直接编译测试代码就好了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ redis_test.cpp -o redis_test -lhiredis</span><br></pre></td></tr></table></figure>
</li>
<li><p>跑一下这个编译之后的可执行程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./redis_test</span><br><span class="line">test finished</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><ul>
<li>这段代码意思还是挺直白的，就是建立一个链接，发送一个命令，然后看回复的类型，然后释放链接</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile parameter: -lhiredis</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    redisContext* context = redisConnect(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">if</span>(!context || context-&gt;err) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; context-&gt;errstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cmd = <span class="string">"redis demo"</span>;</span><br><span class="line">    redisReply* reply = (redisReply*) redisCommand(context, cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!reply) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        redisFree(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(reply-&gt;type == REDIS_REPLY_STATUS)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the status of the context reply is "</span> &lt;&lt; reply-&gt;str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test finished"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hall</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hall</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
