<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="空间配置器简介以STL的运用角度而言,空间配置器是最不需要介绍的东西,它总是隐藏在一切组件后面，组件的实作时处处遇到挡路石。为什么不说allocator是内存配置器而说它是空间配置器呢?因为,空间不一定是内存,空间也可以是磁盘或其它辅助储存媒体。是的,你可以写一个 allocator,直接向硬盘取空间。 空间配置器的标准接口1234567891011121314151617181920212223">
<meta property="og:type" content="article">
<meta property="og:title" content="STL源码学习 1">
<meta property="og:url" content="http://yoursite.com/2018/12/01/stl-analysis1-md/index.html">
<meta property="og:site_name" content="Hall">
<meta property="og:description" content="空间配置器简介以STL的运用角度而言,空间配置器是最不需要介绍的东西,它总是隐藏在一切组件后面，组件的实作时处处遇到挡路石。为什么不说allocator是内存配置器而说它是空间配置器呢?因为,空间不一定是内存,空间也可以是磁盘或其它辅助储存媒体。是的,你可以写一个 allocator,直接向硬盘取空间。 空间配置器的标准接口1234567891011121314151617181920212223">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-11-30T18:58:20.000Z">
<meta property="article:modified_time" content="2022-03-13T10:10:45.294Z">
<meta property="article:author" content="Hall">
<meta property="article:tag" content="C++ and STL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2018/12/01/stl-analysis1-md/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL源码学习 1 | Hall</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hall</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">其实是一个备忘录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/stl-analysis1-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL源码学习 1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-01 02:58:20" itemprop="dateCreated datePublished" datetime="2018-12-01T02:58:20+08:00">2018-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以STL的运用角度而言,空间配置器是最不需要介绍的东西,它总是隐藏在一切组件后面，组件的实作时处处遇到挡路石。为什么不说allocator是内存配置器而说它是空间配置器呢?因为,空间不一定是内存,空间也可以是磁盘或其它辅助储存媒体。是的,你可以写一个 allocator,直接向硬盘取空间。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line">allocator::rebind</span><br><span class="line"><span class="comment">// 一个巢状的(nested)class template。class rebind&lt;U&gt;拥有唯一成员other,</span></span><br><span class="line"><span class="comment">// 那是一个 typedef,代表allocator&lt;U&gt;。</span></span><br><span class="line">allocator::allocator()</span><br><span class="line"><span class="comment">// default constructor。</span></span><br><span class="line">allocator::allocator(<span class="keyword">const</span></span><br><span class="line"> allocator&amp;)</span><br><span class="line"><span class="comment">// copy constructor。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;<span class="title">allocator</span>:</span>:allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span><br><span class="line"><span class="comment">// 泛化的copy constructor。</span></span><br><span class="line">allocator::~allocator()</span><br><span class="line"><span class="comment">// default constructor。</span></span><br><span class="line">pointer allocator::address(reference x) <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 传回某个对象的地址。算式a.address(x)等同于&amp;x。</span></span><br><span class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 传回某个const对象的地址。算式a.address(x)等同于&amp;x。</span></span><br><span class="line"></span><br><span class="line">pointer allocator::allocate(size_type n, cosnt <span class="keyword">void</span>* = <span class="number">0</span>)</span><br><span class="line"><span class="comment">//配置空间,足以储存n个T对象。第二自变量是个提示。实作上可能会利用它来</span></span><br><span class="line"><span class="comment">//增进区域性(locality),或完全忽略之。</span></span><br><span class="line"><span class="keyword">void</span> allocator::deallocate(pointer p, size_type n)</span><br><span class="line"><span class="comment">//归还先前配置的空间。</span></span><br><span class="line">size_type allocator::max_size() <span class="keyword">const</span></span><br><span class="line"><span class="comment">//传回可成功配置的最大量。</span></span><br><span class="line"><span class="keyword">void</span> allocator::construct(pointer p, <span class="keyword">const</span> T&amp; x)</span><br><span class="line"><span class="comment">//等同于new(const</span></span><br><span class="line"><span class="comment">// void*) p) T(x)。</span></span><br><span class="line"><span class="keyword">void</span> allocator::destroy(pointer p)</span><br><span class="line"><span class="comment">// 等同于p-&gt;~T()。</span></span><br></pre></td></tr></table></figure>
<h3 id="自己设计实现一个最简单的空间适配器"><a href="#自己设计实现一个最简单的空间适配器" class="headerlink" title="自己设计实现一个最简单的空间适配器"></a>自己设计实现一个最简单的空间适配器</h3><p><a href="https://github.com/HallWoodZhang/fakestl" title="代码" target="_blank" rel="noopener">代码</a> 文件分别是demo/simpleAllocator0.cpp和demo/simpleAllocator0.h</p>
<p>头文件，在这里std::set_new_handler我没有指派函数给他，所以其实allocator::allocate函数的第二个参数暂时不用理会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simpleAllocator0.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SALLOCATOR_0__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SALLOCATOR_0__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA0 &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> T* _allocate(<span class="keyword">ptrdiff_t</span> size, T* hint) &#123;</span><br><span class="line">        <span class="built_in">std</span>::set_new_handler(<span class="number">0</span>);</span><br><span class="line">        T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size*<span class="keyword">sizeof</span>(T))));</span><br><span class="line">        <span class="keyword">if</span>(!tmp) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of mem"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _deallocate(T* buffer) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _construct(T1* p, <span class="keyword">const</span> T2&amp; val) &#123;</span><br><span class="line">        <span class="keyword">new</span>(p) T1(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _destroy(T* p) &#123;</span><br><span class="line">        p-&gt;~T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">            <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* hint = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span> </span>&#123;</span><br><span class="line">            _deallocate(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">            _construct(p, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;</span><br><span class="line">            _destroy(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (const_pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size_type(UINT_MAX/<span class="keyword">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// end of class allocator</span></span><br><span class="line">&#125; <span class="comment">// end of namespace SA0;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>测试文件simpleAllocator0.cpp，申明一个vector，并且指派自己写的Allocator作为空间适配器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SA0::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia, ia+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"simpleAllocator0.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SA0::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia, ia+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./simpleAllocator0 </span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2 id="具备次配置力-sub-allocation-的-SGI-空间配置器"><a href="#具备次配置力-sub-allocation-的-SGI-空间配置器" class="headerlink" title="具备次配置力( sub-allocation)的 SGI 空间配置器"></a>具备次配置力( sub-allocation)的 SGI 空间配置器</h2><p>由于《STL源码剖析》这本书解读的是SGI版本的STL设计实现，所以我们需要看一些有关方面的特殊实现方法，SGI STL 的配置器与众不同 , 也与标准规范不同 , 其 名 称 是alloc而非allocator,而且不接受任何自变量。换句话说如果你要在程序中明白采用SGI配置器,不能采用标准写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt; iv;<span class="comment">//in VC or CB</span></span><br></pre></td></tr></table></figure>
<p>必须这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::alloc&gt; iv;  <span class="comment">// in GCC</span></span><br></pre></td></tr></table></figure>
<h3 id="SGI-标准的空间配置器-标准的空间配置器-std-allocator"><a href="#SGI-标准的空间配置器-标准的空间配置器-std-allocator" class="headerlink" title="SGI 标准的空间配置器, 标准的空间配置器, std::allocator"></a>SGI 标准的空间配置器, 标准的空间配置器, std::allocator</h3><p>虽然 SGI 也定义有一个符合部份标准、名为allocator的配置器,但SGI自己从未用过它,也不建议我们使用。主要原因是效率不彰,只把 C++的::operator new和::operator delete做一层薄薄的包装而已。下 面是SGI的std::allocator 全貌：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们不赞成含入此文件。这是原始的 HP default allocator。提供它只是为了</span></span><br><span class="line"><span class="comment">//回溯相容。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DO NOT USE THIS FILE 不要使用这个文件,除非你手上的容器是以旧式作法</span></span><br><span class="line"><span class="comment">//完成—那就需要一个拥有 HP-style interface的空间配置器。SGI STL使用</span></span><br><span class="line"><span class="comment">//不同的 allocator界面。SGI-style allocators 不带有任何与对象型别相关</span></span><br><span class="line"><span class="comment">//的参数;它们只回应 void*指标(侯捷注:如果是标准接口,就会响应一个</span></span><br><span class="line"><span class="comment">//「指向对象型别」的指针,T*)。此文件并不含入于其它任何 SGI STL头文件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    set_new_handler(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size * <span class="keyword">sizeof</span>(T))));</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>) &#123;</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> ::allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p)</span> </span>&#123; ::deallocate(p); &#125;</span><br><span class="line">    <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123; <span class="keyword">return</span> (pointer)&amp;x; &#125;</span><br><span class="line">    <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">init_page_size</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(<span class="number">4096</span>/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(UINT_MAX/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本(specialization)。注意,为什么最前面不需加template&lt;&gt;?</span></span><br><span class="line"><span class="comment">//见 1.9.1 节的组态测试。注意,只适用于 GCC。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的两行注释是候捷写的，我自己测了不行，还是要按照标准来</span></span><br><span class="line"><span class="comment">// 然而事实上，我使用gcc8.2.0测试，这条是通不过的，还是需要加上template&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in gcc 8.2.0</span></span><br><span class="line"><span class="comment">// template&lt;&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span>&lt;void&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SGI特殊的空间配置器std-alloc"><a href="#SGI特殊的空间配置器std-alloc" class="headerlink" title="SGI特殊的空间配置器std::alloc"></a>SGI特殊的空间配置器std::alloc</h3><p>上一次所写到，也就是SGI中的Allocator只是对于::operator delete和::operator new的一个简单的包装，并没有任何效率上的优化，其在文档中也不建议我们來直接使用这个allocator</p>
<p>一般的，我们使用C++来构建对象的过程是如下的一个过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> demo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo* pfoo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">delete</span> pfoo;</span><br></pre></td></tr></table></figure>
<p>这其中的new算式内包含两个阶段的动作：</p>
<ol>
<li>call ::operator new配置内存</li>
<li>call Foo::Foo()函数来构建对象内容</li>
</ol>
<p>delete语句内也包含了两个动作</p>
<ol>
<li>call Foo::~Foo()函数析构对象</li>
<li>call ::operator delete来释放内存</li>
</ol>
<p>STL的标准告诉我们，配置器的定义在”memory”这个头文件中，在SGI版本的memory有包含两个文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt; // 负责空间的分配和释放</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt; // 负责内容的构建和析构</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stl_uninitialized.h&gt; 这个之后再说</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这里定义有一些全域函式,用来充填(fill)</span></span><br><span class="line"><span class="comment">	或复制(copy)大块内存内容,它们也都</span></span><br><span class="line"><span class="comment">	隶属于 STL 标准规范:</span></span><br><span class="line"><span class="comment">	un_initialized_copy()</span></span><br><span class="line"><span class="comment">	un_initialized_fill()</span></span><br><span class="line"><span class="comment">	un_initialized_fill_n()</span></span><br><span class="line"><span class="comment">    这些函式虽不属于配置器的范畴,但与对象初值</span></span><br><span class="line"><span class="comment">    设定有关,对于容器的大规模元素初值设定很有</span></span><br><span class="line"><span class="comment">    帮助。这些函式对于效率都有面面俱到的考虑,</span></span><br><span class="line"><span class="comment">    最差情况下会呼叫construct(),</span></span><br><span class="line"><span class="comment">    最佳情况则使用C标准函式memmove() 直接进行</span></span><br><span class="line"><span class="comment">    内存内容搬移。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这两个文件分别负责一个对象的出生/消亡的两个步骤，在stl_construct函数中定义了construct()和destroy()这两个基本的函数</p>
<h3 id="构造和析构的基本工具：-construct-和destroy"><a href="#构造和析构的基本工具：-construct-和destroy" class="headerlink" title="构造和析构的基本工具： construct()和destroy()"></a>构造和析构的基本工具： construct()和destroy()</h3><p>我们先看看在&lt;stl_construct.h&gt;中的部分内容</p>
<p>我们以两个模板参数版本的construct()函数为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向__p指向的内存塞入一个用_T1::_T1(const _T2&amp; __val)函数构造的对象</span></span><br><span class="line"><span class="comment">// 这个功能在头文件&lt;new&gt;中有</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">	<span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1(__value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">	_Construct(__p, __value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以迭代取版本和指针版本的destroy函数为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 第一对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">	__pointer-&gt;~_Tp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">	_Destroy(__pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	_Destroy(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	__destroy(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>补充说明：<br>对于某一个对象，如果用户不定义析构函数，而是用系统自带的，则说明，析构函数基本没有什么用（但默认会被调用）我们称之为trivial destructor。反之，如果特定定义了析构函数，则说明需要在释放空间之前做一些事情，则这个析构函数称为non-trivial destructor。如果某个类中只有基本类型的话是没有必要调用析构函数的，delelte p的时候基本不会产生析构代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对于具有trivial析构函数的对象，不用p-&gt;~T()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span>, _<span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象具有non-trivial析构函数，需要显式的析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    	destroy(&amp;*__first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外的一些对象的destoy函数的特化版，实际上，它们什么都没做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">char</span>*, <span class="keyword">char</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">int</span>*, <span class="keyword">int</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">long</span>*, <span class="keyword">long</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">float</span>*, <span class="keyword">float</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">double</span>*, <span class="keyword">double</span>*) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_HAS_WCHAR_T</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_HAS_WCHAR_T */</span></span></span><br></pre></td></tr></table></figure>
<p>显然的，这些数据经过“摧毁”后，真的消失了吗？并没有，他们还在内存里面，只不过他们所占用的位置被某种方式定为“没有被使用过的”内存区域了（我还没看到书中关于这方面的解释，可能后面会有），这就是为什么我们每次定义一个基本类型的对象，如果未初始化，那么它的值还有上一次销毁的数据的影子，就像“幽灵”一样</p>
<p>又有人要问了，这些函数什么都不做，会不会太不负责任？准备将[first,last) 范围内的所有对象析构掉。我们不知道这个范围有多大,万一很大,而每个物件的解构式都无关痛痒(所谓 trivial-destructor),那么一次次呼叫这些无关痛痒的解构式,对效率有不利影响。因此,这里首先利用value_type()获得迭代器所指物件的型别,再 利 用”type_traits<t>“判 别 该 型 别 的 解 构 式 是 否 无 关 痛 痒 。 若 是true_type,什么也不做就结束;若否false_type,这才以循环方式巡访整个范围,并在循环中每经历一个对象就呼叫第一个版本的 destroy()。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	__destroy(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的想法是很好,但 C++本身并不直接支持对「指标所指之物」的型别判断」，那么VALUE_TYPE(__first)是什么？我们之后再讨论这个问题</p>
<h3 id="空间的配置和释放-std-alloc-in-SGI-STL"><a href="#空间的配置和释放-std-alloc-in-SGI-STL" class="headerlink" title="空间的配置和释放 std::alloc in SGI-STL"></a>空间的配置和释放 std::alloc in SGI-STL</h3><p><strong>注意，我们讨论的是SGI-STL版本，不是标准版本</strong></p>
<p>大致的看完了内存配置后的对象构建行为，和内存对象的析构行为，现在我们来到了内存的分配和释放</p>
<p>对象构建前的空间配置，和对象析构之后的空间回收有stl_alloc.h负责</p>
<p>SGI-STL对此的设计哲学如下：</p>
<ol>
<li>向system heap要更多的空间</li>
<li>更多的考虑多线程的情况（multi-thread）</li>
<li>考虑内存不足的应对</li>
<li>考虑过多「小型区域」的申请造成的内存碎片问题（fragment）</li>
</ol>
<p>为了我和你的小心脏和不聪明的脑袋，我尽量在接下来讨论排除multi-thread状态的情况</p>
<p><strong>台湾程序员把allocator叫配置器，我们这边就按他这么叫吧，嘻嘻</strong></p>
<p>C++ mem分配的基本操作是::operator new(), mem 的释放基本操作是::operator delete()。这两个全局函数相当于C中的malloc和free()，正是因为此，SGI-STL中使用了malloc和free函数</p>
<p>考虑到「小型区域」的多次分配招成的内存碎片问题，SGI-STL设计了双层级配置器，第一级直接使用了malloc和free，第二级则视情况的不同采用了不同的策略</p>
<p>当分配的内存超过128 Bytes，视为「足够大的内存申请」，便直接调用第一级的配置器，反之，我们认为这个请求是「小内存申请请求」，为了降低额外负担，便采用了复杂的整理方式整理内存池，而不是直接调用第一级的空间配置器</p>
<p>整个设计究竟只开放第一级配置器,或是同时开放第二级配置器,取决USE_MALLOC是否被定义(唔,我们可以轻易测试出来,SGI STL并未定义USE_MALLOC):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc single_client_alloc;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure>
<p>无论alloc被定义为第一级或第二级配置器,SGI还为它再包装一个接口如下,<br>使配置器的接口能够符合 STL规格:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> _<span class="function">Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*) _Alloc::allocate(__n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="keyword">static</span> _<span class="function">Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (_Tp*) _Alloc::allocate(<span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::deallocate(__p, __n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">      </span>&#123; _Alloc::deallocate(__p, <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SGI-STL第一级空间分配器的大致工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span> </span><br><span class="line">	<span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>allocate()成员函数直接使用C-type malloc函数</li>
<li>deallocate()成员函数直接使用C-type free函数</li>
<li>模拟C++中的std::set_new_handler来处理内存不足的情况</li>
</ol>
<p>SGI-STL第二季空间配置器的大致工作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>负责维护16个自由串行表，来维护16种小型内存块的分配，内存池以malloc来获得（调用第一级malloc一个大的内存块），如果申请的内存池不足，呼叫调用第一级适配器以获得更大的内存池</li>
<li>如果申请的内存大于128bytes那么直接调用第一级空间配置器</li>
</ol>
<h3 id="第一级适配器-malloc-alloc-template-解析"><a href="#第一级适配器-malloc-alloc-template-解析" class="headerlink" title="第一级适配器 malloc_alloc_template 解析"></a>第一级适配器 malloc_alloc_template 解析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THROW_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> __THROW_BAD_ALLOC fprintf(stderr, <span class="meta-string">"out of memory\n"</span>); exit(1)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span> <span class="comment">/* Standard conforming out-of-memory handling */</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> __THROW_BAD_ALLOC throw std::bad_alloc()</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>类的定义（这里用的直接是SGI_STL的源码，代码风格就是这样有很多下划线）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 一般而言，是thread-safe的</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当没有足够的内存的时候的处理函数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个简单的函数指针 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 非常直接，直接申请空间，出错交给oom_handler处理</span></span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 对free的简单包装</span></span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 同allocate的处理方式  </span></span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下模拟 C++的 set_new_handler(). 换句话说，你可以透过它，</span></span><br><span class="line">  <span class="comment">//指定你自己的 out-of-memory handler</span></span><br><span class="line">  <span class="comment">// 这段代码看不懂的可以看看这个分析</span></span><br><span class="line">  <span class="comment">// https://glemontree.github.io/2017/10/23/[C++]%20static%20void%20(%20__set_malloc_handler(void%20(__f)()))()/</span></span><br><span class="line">  <span class="comment">// 拆开一层一层的分析，最内部的__f是一个函数指针，其参数为void，返回值为void。</span></span><br><span class="line">  <span class="comment">// 对于__set_malloc_handler，首先它是一个函数，其参数为形如__f的函数指针，其返回值也是一个指针，这个指针的类型是void(*)()</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">( * __set_malloc_handler( <span class="keyword">void</span> (*__f)() ) )</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于初始out-of-mem handler的设置，直接设置为nullptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 不断的配置，知道分配到新的内存为止</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化__inst = 0的情况 __malloc_alloc_template&lt;0&gt;为malloc_alloc;</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>
<p>第一级空间分配器以，malloc，free，realloc等C函数执行实际的内存的分配，释放重释放过程。并且作出类似std::set_new_handler()的机制，而不是实际调用C++ std::set_new_handler()组件，因为SGI-STL并没有使用::operator new和::opertor delete来分配和释放内存。</p>
<p>所谓 C++ new handler 机制是,你可以要求系统在内存配置需求无法被满足时,<br>唤起一个你所指定的函式。换句话说一旦::operator new无法达成任务,在丢出去std::bad_alloc异常状态之前，会先调用程序员指定的out_of_mem_handler函数，这个可以由程序员自己编写。</p>
<p>为什么SGI_STL不采用C++标准的::operator new()和::operator delete()作为分配和释放内存的原子操作呢？个人认为可能有以下两点原因：</p>
<ol>
<li>C++ 并没有提供一个类似于realloc的一个充分配动作</li>
<li>一些历史因素</li>
</ol>
<p>所以SGI_STL不使用::operator new和delete，连带的，也就不能使用std::set_new_handler这个组件来对应处理内存不够的情况，为此，SGI-STL的作者自己实现了一个类似的机制</p>
<p>需要注意的是，SGI-STL的第一级空间分配器allocate和reallocate都是在malloc和realloc两个C-type函数不成功以后才会调用S_oom_alloc和S_oom_realloc这两个函数，这两个函数有一个内循环会不停的尝试申请新的内存，知道成功为止，但是当程序员并没有设置malloc_alloc_oom_handle这个函数指针，那么，THROW_BAD_ALLOC就会被执行（这个宏具体就是抛出异常并exit当前进程）</p>
<p>设计内存不足的时候的处理程序是使用者程序员的责任，据说解决这个问题有一套特定的模式，这里就不再细究了。</p>
<h3 id="第二级空间分配器"><a href="#第二级空间分配器" class="headerlink" title="第二级空间分配器"></a>第二级空间分配器</h3><p>第二级空间分配器相比第一级简陋的分配器，有了许多的机制和判断逻辑。小区域动态内存的申请带来的不仅仅是内存碎片的问题，分配的时候，每一片内存的额外负担也是一个很大的问题，毕竟系统要靠这个来管理内存，先前我们提到，很多情况下内存在数据中并没有消失，只是被以某种形式记录为“未被使用的”，假设我们要给一个指针pa申请一块动态的内存空间，那么在pa = new object()，执行之后pa所指的内存空间存在着一个object()默认构造函数构造过的对象，但是在pa - (cookie_size)所指向的空间中存在一个用来记录pa大小和是否被使用的记录数据块（cookie），这也就是说每次申请x bytes内存，<strong>实际上就有x + cookie_size bytes的内存被申请</strong>，这也就意味着，x越小，内存的利用效率越低</p>
<p>而SGI-STL的第二级分配器做法是，如果区域足够大，超过了128bytes,那么就移交给第一级适配器，当申请的内存区域小于128bytes时，则使用内存池（memory pool）来管理这些小的内存块，这种方法又被称为sub-allocation：</p>
<ul>
<li>每次都分配一块很大的内存区域，并且使用空闲列表free_list来管理</li>
<li>如果用户有小区域内存的需求，直接从free_list中找到空闲的结点（空闲的块，有点像文件系统中datanode）</li>
<li>如果用户释放小型内存区域，则直接将这块大小的内存并入free_list链表</li>
<li><strong>需要注意的是，在这种机制下无论分配还是释放，free_list都会把申请的内存区域整理为8 bytes的整数倍（打个比方，用户申请30bytes的内存空间，那么allocator会充free_list_32bytes_sz中分配一个32bytes的可用内存给用户，用户如果释放30bytes内存，那么allocator会强行把后面附加的2bytes也一并回收）</strong>，allocator维护16个free_list链表，分别负责8,16,24,32,40,48 … 128 bytes的内存分配和释放，free_list类似结构如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> free_list_node_bytes &#123;</span><br><span class="line">    <span class="keyword">union</span> free_list_node_bytes* next;</span><br><span class="line">    <span class="keyword">char</span> data_area[SIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于C-type代码足够的灵活，使用union我们不用担心指针的额外开销，这么骚的操作你在Java这种强类型语言中是绝对看不到的233</p>
<p>下面，让我们来康康第二级SGI-STL空间配置器大致的实现吧，由于我个人认为书中的代码相比其实际代码可读性（主要是原代码宏还有下划线太多啦，还涉及到一些多线程方面的情况）更好并且原理上是一样的，这里直接贴书上的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;<span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;<span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="comment">//free-lists个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是第二级配置器。</span></span><br><span class="line"><span class="comment">//注意,无「template 型别参数」,且第二参数完全没派上用场。</span></span><br><span class="line"><span class="comment">//第一参数用于多绪环境下。本书不讨论多绪环境。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> ints&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">defaut_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// ROUND_UP函数把bytes上调至8的整数倍</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 要好好复习一下单目运算	</span></span><br><span class="line">		<span class="comment">// new_bytes = 8n + x + 7 &amp; 7</span></span><br><span class="line">		<span class="comment">// if x == 0 new_bytes = 8n</span></span><br><span class="line">		<span class="comment">// else if x &gt; 0 then x + 7 &gt;= 8 产生进位故(8n + x + 7 &amp; 7) == (8n + 8)</span></span><br><span class="line">		<span class="keyword">return</span> (((bytes) + __ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)__ALIGN - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj* free_list_link;</span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// volatile不知道什么意思的请使用Google搜索</span></span><br><span class="line">	<span class="comment">// 或看看这篇博客：https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html</span></span><br><span class="line">	<span class="comment">// 16个free list</span></span><br><span class="line">	<span class="keyword">static</span> obj* <span class="keyword">volatile</span> free_list[____NFREELISTS];</span><br><span class="line">	<span class="comment">// 下面根据函数区块大小，决定使用第N个free_list;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// eg: 8 + 7 = 15, 15 / 8 = 1, 1 - 1 = 0</span></span><br><span class="line">		<span class="comment">// 这是程序员经常使用的一条数学式子</span></span><br><span class="line">		<span class="keyword">return</span> (((bytes) +__ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 传回一个大小是N的对象，并可能加入大小为n的其他区块到free_list</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分配一个大块空间可容纳 nobjs 个大小为 "size" 的区块。</span></span><br><span class="line">	<span class="comment">// 如果配置 nobjs个区块有所不便,nobjs可能会降低。</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Chunk allocation state.</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* start_free;<span class="comment">//记忆池起始位置。只在 chunk_alloc()中变化</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* end_free;<span class="comment">//记忆池结束位置。只在 chunk_alloc()中变化</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="comment">/* 之后再讨论 */</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span> </span>&#123; <span class="comment">/* 之后再讨论 */</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能初始化的时候这么干</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, <span class="keyword">bool</span>&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, <span class="keyword">bool</span>&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] = </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="空间分配函数allocator"><a href="#空间分配函数allocator" class="headerlink" title="空间分配函数allocator()"></a>空间分配函数allocator()</h4><p>身为一个空间分配器，default_alloc_template拥有分配器的标准接口allocate()。这个函数首先判断申请的内存区域的大小，大于128bytes会调用第一级空间分配器，否则就检查对应的free_list，如果free_list有空闲的区块，那么直接分配空闲区块，如果没有足够的空闲区块，则调整区块大小至8的倍数，然后调用本类内的refill函数，重新为free_list填充足够的内存空间</p>
<p>在default_alloc_template类内<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这是一个二级指针</span></span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj* result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大于128bytes则直接调用第一级的空间分配器</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找16个free_list中合适的那一个</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        <span class="comment">// 没有找到可用的free_list</span></span><br><span class="line">        <span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配完free_list结点之后</span></span><br><span class="line">    *my_free_list = result-&gt;free_list_link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空间释放器deallocator"><a href="#空间释放器deallocator" class="headerlink" title="空间释放器deallocator()"></a>空间释放器deallocator()</h4><p>default_alloc_template拥有便准的deallocate()。这个函数首先判断处理的内存区块的大小，大于128 bytes就呼叫第一级的空间释放器，小于128bytes就找出对应的free_list，并且将区块回收</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p != nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    obj* q = (obj* ) p;</span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::deallocate(p, n);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找对应的free_list</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整free_list</span></span><br><span class="line">    q -&gt; free_list_link = *my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收区块</span></span><br><span class="line">    *my_free_list = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重新填充free-list-refill"><a href="#重新填充free-list-refill" class="headerlink" title="重新填充free_list: refill"></a>重新填充free_list: refill</h4><p>我们之前讨论过的，就是当申请内存的时候，当free_list不够用的时候，当它发现free_list就调用refill()准备为free_list重新填充空间。新的空间将取自内存池，内存池的申请由chunk_alloc来完成。预设取得20个新结点，但是万一内存池空间不足获得的结点数可能要小于20</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传回一个大小是n的对象，并且有时候会为free_list填充适当的结点</span></span><br><span class="line"><span class="comment">// 我们假设n已经上调至8的整数倍</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> ints&gt;</span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, ints&gt;::refill(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 调用chunk_alloc()，取得nobjs个区块作为free_list的新结点</span></span><br><span class="line">    <span class="comment">// 值得注意的是nobjs是一个引用传值参数</span></span><br><span class="line">    <span class="keyword">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">    obj* result;</span><br><span class="line">    obj* current_obj;</span><br><span class="line">    obj* next_obj;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果只获得一个区块，这个区块就拨给调用者使用free_list并没有增加任何新的结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则准备调整free_list，纳入新的结点</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下在chunk空间内建立free_list</span></span><br><span class="line">    result = (obj*)chunk;</span><br><span class="line">    </span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下free_list各个结点串接起来</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; ;++i) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj*)((<span class="keyword">char</span>*) next_obj + n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存池分配chunk-alloc"><a href="#内存池分配chunk-alloc" class="headerlink" title="内存池分配chunk_alloc"></a>内存池分配chunk_alloc</h4><p>从内存池中取得新的空闲空间给free list使用，这是chunk_alloc的职责：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设size已经上调至8的整数倍</span></span><br><span class="line"><span class="comment">// nobjs是一个引用参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size*nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line">    <span class="keyword">if</span>(bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        <span class="comment">// 当内存池的容量还满足需求的时候</span></span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// 当内存池的空间不够,但是能够供应一个以上的size空间的时候</span></span><br><span class="line">        nobjs = bytes_left / size;</span><br><span class="line">        total_bytes = size*nobjs;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当内存池剩余空间连一个块都无法提供的时候</span></span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span>*total_bytes + (ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 以下操作试图利用残余的小内存池空间</span></span><br><span class="line">        <span class="keyword">if</span>(bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 内存池中还有一些零头</span></span><br><span class="line">            <span class="comment">// 我在这里卡了一会，因为无法理解如果内存池内剩余的空间不足8bytes的情况下这么写怎么会行的通，后来我想通了。</span></span><br><span class="line">            <span class="comment">// 因为无论是内存池的申请还是使用，都是以8bytes的整数倍为单位进行的，当还有剩余空间的时候，它必然是8bytes的整数倍，这句if语句你可以理解为if(bytes_letft &gt;0 &amp;&amp; bytes_left &gt;= 8)</span></span><br><span class="line">            obj* <span class="keyword">volatile</span>* my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">            ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">            *my_free_list = (obj*)start_free;</span><br><span class="line">        &#125; <span class="comment">// end if</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置Heap空间</span></span><br><span class="line">        start_free = (<span class="keyword">char</span>* )<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == start_free) &#123;</span><br><span class="line">            <span class="comment">// heap空间不足,malloc失败</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">            obj *p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试检查我们手头拥有的东西</span></span><br><span class="line">            <span class="comment">// 我们不打算分配较小的内存块，因为那在多进程机器上容易造成灾难性的后果</span></span><br><span class="line">            <span class="comment">// 搜索适当的free_list</span></span><br><span class="line">            <span class="comment">// 所谓适当是指「还有没有使用的区块，且区块够大」的free_list</span></span><br><span class="line">            <span class="keyword">for</span>(i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">                p = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != p) &#123;</span><br><span class="line">                    <span class="comment">// 这个free_list还有空闲的区块</span></span><br><span class="line">                    *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                    start_free = (<span class="keyword">char</span>*) p;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 递归调用自己来修正nobjs</span></span><br><span class="line">                    <span class="keyword">return</span> chunk(size, nobjs);</span><br><span class="line">                &#125; <span class="comment">// end if</span></span><br><span class="line">            &#125; <span class="comment">// end for</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果经过上面的挣扎还没有办法得到内存并return退出函数</span></span><br><span class="line">            <span class="comment">// 只能调用第一级内存分配器了，因为第一级分配器函数有out-of-memory处理机制（之前提到的）</span></span><br><span class="line">            end_free = <span class="number">0</span>;</span><br><span class="line">            start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">        &#125; <span class="comment">// end of if(0 == start_free)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可喜可贺，如果malloc成功了，你可以不用理会那么多</span></span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + heap_size;</span><br><span class="line">        <span class="comment">// 递归调用自己以修正nobjs</span></span><br><span class="line">        <span class="keyword">return</span> chunk_alloc(size, nobjs);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// end if...else if ... else ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数看得我心情澎湃，居然代码还可以这么写</p>
<p>我们简单的总结一下，chunk_alloc它具体都作了一些什么</p>
<ul>
<li>判断内存池的剩余空间end_free - start_free<ul>
<li>如果有足够的剩余空间给20个size使用，那么直接划拨给用户20个size的chunk</li>
<li>不够20个的，但至少能够分配一个的，能分配几个就分配几个size的区块</li>
<li>内存池连一个size都拿不出来，穷得叮当响，那么把剩余内存池空间放入free_list（由于内存池无论是是申请还是使用都是8bytes的整数倍为单位进行操作的，所以剩余的空间一定是8bytes的整数倍，可以直接放入free_list），这种情况下我们再进行以下动作<ul>
<li>直接用malloc申请一个新的内存池<ul>
<li>申请成功，以新的内存池为基础，递归调用自己并返回修正nobjs</li>
<li>申请失败，寻找是否有剩余的free_list空间，要求他把吃掉的内存吐出来，如果这样还是找不到合适的内存，那么万念俱灰，变成咸鱼（把事情推给别人去做），交给第一级分配器去处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义了五个全局函数，作用在未初始化的内存空间中，这样的功能呢个对于容器的实际构造很有帮助。我们看到除了之前提到过得construct和destroy函数之外，还有三个用来使用大段内存初始化容器的函数，分别是uninitialized_copy(), uninitialized_fill(), uninitialized_fill_n()，分别对应于高阶函数copy，fill，fill_n。你在实际使用中应该包含在”memory”头文件中，不过我们本地保存的SGI-STL代码把他们的实现放到了stl_uninitialized</p>
<h3 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) ;</span></span><br></pre></td></tr></table></figure>
<p>uninitialized_copy() 使我们能够将内存的配置与对象的构造行为分离开，如果作为输出目的地 [result, result + (last - first)) 左闭右开范围内的每一个迭代器都指向一个未经过初始化或者构造的对象区域，则uninitialized_copy函数会使用复制构造函数，分别以[first, last)左闭右开区间内的每一个对象复制构造到result所指的区间内。,针对输入范围内的每一个迭代器 i,此函式会调用construct(&amp;<em>(result+(i-first)),</em>i) ,产生*i的复制品,放置于输出范围的相对位置上。</p>
<p>C++标准要求uninitialized_copy的行为是：</p>
<ul>
<li>如果所有的复制构造函数都成功运行，那么构造成功</li>
<li>如果其中有一个失败了，你不仅不能继续构建下去，甚至还要想办法回退(rollback)</li>
</ul>
<h3 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ForwardIterator, class T&gt;</span><br><span class="line">void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T&amp; x);</span><br></pre></td></tr></table></figure>
<p>行为：</p>
<ul>
<li>在 [first, last) 区间为每一个对象使用x作为引用参数调用赋值构造函数</li>
<li>不成功就回退，这点和uninitialized_copy有点类似</li>
</ul>
<p>uninitialized_copy()和uninitialized_fill()必须具备”commit or rollback”语意,换句话说它要不就产生出所有必要元素,要不就不产生任何元素。<br>如果有任何一个copy constructor丢出异常(exception),uninitialized_fill()<br>必须能够将已产生之所有元素解构掉。</p>
<h3 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>);</span></span><br></pre></td></tr></table></figure>
<p>行为：</p>
<ul>
<li>和uninitialized_fill本质上意思是一样的，只不过区间的表达方法不一样</li>
<li>也具有commit-or-rollback语义特性</li>
</ul>
<p>具体实现之后放出，它们依赖于一种叫做POD（plain old data）的布尔模板参数来判断函数泛化后的不同实现</p>
<p>所谓POD，我说的直白一点，就是C-type的struct类似的类,它的每一个成员变量都是紧贴在一起的且没有别的“杂质”字节，比如虚指针和函数指针什么的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> <span class="title">tmp</span> = (<span class="title">struct</span> <span class="title">Tmp</span>)&#123;</span><span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;; <span class="comment">// 这样初始化可行</span></span><br><span class="line"><span class="keyword">char</span>* p = ((<span class="keyword">char</span>*)&amp;tmp) + <span class="number">2</span>;</span><br><span class="line">*p == <span class="string">'c'</span>; <span class="comment">// true</span></span><br><span class="line">*p = <span class="string">'k'</span>;</span><br><span class="line">tmp.c == k; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>struct Tmp就是POD类型的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以fill_n版本的实现为例</span></span><br><span class="line"><span class="comment">// 第三级调用POD版本，直接调用高阶函数fill_n</span></span><br><span class="line"><span class="comment">// fill_n和其他两个高阶函数，我们以后会讨论</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 当__x是POD直接调用fill_n</span></span><br><span class="line">  <span class="keyword">return</span> fill_n(__first, __n, __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三级调用非POD形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __cur = __first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="comment">// 当__x并不是POD的时候，老老实实的调用构造函数来复制</span></span><br><span class="line">    <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__cur)</span><br><span class="line">      _Construct(&amp;*__cur, __x);</span><br><span class="line">    <span class="keyword">return</span> __cur;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 你好，你有成员构造函数执行失败了，请回滚</span></span><br><span class="line">  __STL_UNWIND(_Destroy(__first, __cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二级调用在这里发生</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Tp1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, _<span class="title">Tp1</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里才是入口哦,第一级调用在这里发生</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></span><br><span class="line"><span class="class"><span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>) &#123;</span></span><br><span class="line">	<span class="keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现：又出现了，那个玄学value_type()，还有is_pod判定函数，这个要到书的后面才会讲实现原理。</p>
<ul>
<li>用户调用uninitialized_fill_n</li>
<li>uninitialized_fill_n 调用 __uninitialized_fill_n</li>
<li><strong>uninitialized_fill_n 调用 </strong>uninitialized_fill_n_aux</li>
<li>__uninitialized_fill_n_aux根据复制来源是否是POD来选择显式的调用构造函数并且显式的回滚，还是直接调用fill_n来填充内存</li>
</ul>
<p>而至于没有讲到的uninitialized_copy和uninitialized_fill，大致的行为都是类似的</p>
<p>至此我们这一个章节暂时告一段落，永远不要停止学习！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-and-STL/" rel="tag"># C++ and STL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/11/26/stl_analysis0/" rel="prev" title="关于STL代码学习和实践(0)">
      <i class="fa fa-chevron-left"></i> 关于STL代码学习和实践(0)
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/25/tiny_socket/" rel="next" title="用C++实现一个非常简单的socket即时通信机制">
      用C++实现一个非常简单的socket即时通信机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">空间配置器的标准接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">自己设计实现一个最简单的空间适配器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E5%A4%87%E6%AC%A1%E9%85%8D%E7%BD%AE%E5%8A%9B-sub-allocation-%E7%9A%84-SGI-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">1.3.</span> <span class="nav-text">具备次配置力( sub-allocation)的 SGI 空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SGI-%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8-%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8-std-allocator"><span class="nav-number">1.3.1.</span> <span class="nav-text">SGI 标准的空间配置器, 标准的空间配置器, std::allocator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SGI%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8std-alloc"><span class="nav-number">1.3.2.</span> <span class="nav-text">SGI特殊的空间配置器std::alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%EF%BC%9A-construct-%E5%92%8Cdestroy"><span class="nav-number">1.3.3.</span> <span class="nav-text">构造和析构的基本工具： construct()和destroy()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E9%87%8A%E6%94%BE-std-alloc-in-SGI-STL"><span class="nav-number">1.3.4.</span> <span class="nav-text">空间的配置和释放 std::alloc in SGI-STL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%80%82%E9%85%8D%E5%99%A8-malloc-alloc-template-%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.5.</span> <span class="nav-text">第一级适配器 malloc_alloc_template 解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">1.3.6.</span> <span class="nav-text">第二级空间分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0allocator"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">空间分配函数allocator()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE%E5%99%A8deallocator"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">空间释放器deallocator()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%A1%AB%E5%85%85free-list-refill"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">重新填充free_list: refill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E5%88%86%E9%85%8Dchunk-alloc"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">内存池分配chunk_alloc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">1.4.</span> <span class="nav-text">内存基本处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-copy"><span class="nav-number">1.4.1.</span> <span class="nav-text">uninitialized_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-fill"><span class="nav-number">1.4.2.</span> <span class="nav-text">uninitialized_fill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-fill-n"><span class="nav-number">1.4.3.</span> <span class="nav-text">uninitialized_fill_n</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hall</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hall</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
