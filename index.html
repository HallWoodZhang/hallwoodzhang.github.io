<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hall">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hall">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hall">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hall</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hall</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我的网上笔记本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/13/gRPC-learn-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/13/gRPC-learn-1/" class="post-title-link" itemprop="url">gRPC学习 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-13 18:13:24 / 修改时间：19:13:54" itemprop="dateCreated datePublished" datetime="2022-03-13T18:13:24+08:00">2022-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习gRPC-01"><a href="#学习gRPC-01" class="headerlink" title="学习gRPC 01"></a>学习gRPC 01</h1><p>好久没有文档了</p>
<p>最近在学习如何使用gRPC，之前在做项目的时候曾经使用过这种工具来实现内部微服务之间的通信，但是由于一直没有系统性的学习和整理，所以总是不记得很多关键信息和步骤，使用的时候老是要去查，这一次专门写一个文档和说明将这部分内容保存下来</p>
<p>参考书籍是</p>
<p>《gRPC与云原生应用开发：以GO和Java为例》</p>
<h2 id="首先，什么是gRPC"><a href="#首先，什么是gRPC" class="headerlink" title="首先，什么是gRPC"></a>首先，什么是gRPC</h2><p>gRPC是一项进程间通信技术，可以用来链接、调用、操作和调试分布式异构应用程序。</p>
<p>在开发gRPC程序的时候，首先要定义服务接口，其中应该包含如下信息：</p>
<ul>
<li>消费者消费服务的方式</li>
<li>消费者远程调用的方式</li>
<li>调用这些方法所需要的参数和格式</li>
</ul>
<p>在服务定义中，使用的语言称之为<strong>接口定义语言（interface definition language, IDL）</strong></p>
<p>借助服务定义，可以生成服务端代码，它通过封装了一系列底层的接口使得调用过程看起来非常简单。同时，还可以生成客户端代码，封装抽象了客户端的通信过程，为不同的编程语言隐藏了底层级的通信逻辑。底层的gRPC框架帮开发者干复杂的脏活，并且保证可参数强校验，数据序列化，认证，网络通信，访问限制和可观察性等。</p>
<h2 id="为什么要用gRPC，他有哪些优势"><a href="#为什么要用gRPC，他有哪些优势" class="headerlink" title="为什么要用gRPC，他有哪些优势"></a>为什么要用gRPC，他有哪些优势</h2><ul>
<li>提供高效的进程间通信</li>
</ul>
<p>gRPC没有使用JSON或者XML这样的文本化格式，而是使用一个基于protocol buffers的二进制协议与gRPC的客户端进行通信。同时，gRPC在HTTP/2上实现了protocol buffers，从而更快的处理进程间通信。</p>
<ul>
<li>具有简单且定义良好的服务接口和模式</li>
</ul>
<p>gRPC为应用程序开发提供里一种契约优先的应用开发模式。开发对接的客户端开发者和服务端开发者必须要定义服务接口，然后才能去处理实现细节，gRPC强制双方按照规矩行事，提供了简单一致，可靠可扩展的应用程序开发体验</p>
<ul>
<li>强类型</li>
</ul>
<p>因为使用了protocol buffers来定义gRPC服务，所以gRPC服务七月清晰定义了应用程序间进行通信的所有类型。这样一来可以在构建涉及到多个团队和微服务的云原生应用程序的时候，避免绝大多数运行时传参错误，使得风不是应用程序的开发更加稳定。</p>
<ul>
<li>支持多语言</li>
</ul>
<p>gRPC支持多种编程语言，基于protocol buffers的服务定义是语言中立的。</p>
<ul>
<li>支持双工流</li>
</ul>
<p>gRPC早客户端和服务端都提供了对流的原生支持，这些功能都被整合到了服务定义本身之中。所以基于此框架开发流服务端和流客户端都变得非常简单。与传统的RESTful服务消息风格相比，gRPC的关键优势是能够同时构造同步的请求-响应风格应用，以及基于流的应用。</p>
<ul>
<li>商业化、工程化特性</li>
</ul>
<p>gRPC内置认证、加密、弹性（截止时间和超时）、元数据交换、压缩、负载均衡、服务发相等特性</p>
<ul>
<li>与云原生生态兼容性良好</li>
</ul>
<p>gRPC是CNCF的一部分，大部分现代的框架和技术对gRPC提供了原生支持。CNCF下的很多项目（如Envoy）支持使用gRPC作为通信协议。另外，对于大多数度量和监控工具，也对gRPC提供了支持，比如Prometheus来监控gRPC应用程序</p>
<ul>
<li>已经成熟并被广泛使用</li>
</ul>
<p>很多大型IT和互联网公司都对广泛使用gRPC，对其进行了大量的测试。</p>
<h2 id="gRPC的劣势"><a href="#gRPC的劣势" class="headerlink" title="gRPC的劣势"></a>gRPC的劣势</h2><ul>
<li>不适合构造面向外部服务的接口</li>
</ul>
<p>大多数外部消费者对gRPC，http，REST等协议很陌生。如果希望应用程序或者服务通过互联网暴露给外部客户端，gRPC的强约束性会限制外部暴露服务的灵活性，同时消费者的控制权也会弱很多</p>
<ul>
<li>频繁的变更或者巨大的变更可能会带来更多的工作量消耗</li>
</ul>
<p>在现代服务间通信场景中，修改一些参数或者模式很正常。如果出现大的服务定义（也就是proto定义）变更，通常需要重新生成对应的客户端代码和服务端代码</p>
<ul>
<li>泛用性来说，生态系统相对更小</li>
</ul>
<p>与传统的RESTful http等协议相比，gRPC的生态系统还明显相对较小，浏览器和移动应用程序对gRPC的支持还处于一个比较初级的阶段</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/Advanced-Programming-in-the-UNIX-Environment-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/17/Advanced-Programming-in-the-UNIX-Environment-1/" class="post-title-link" itemprop="url">Advanced Programming in the UNIX Environment 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-17 21:13:20" itemprop="dateCreated datePublished" datetime="2019-06-17T21:13:20+08:00">2019-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter1-Unix-基础知识"><a href="#Chapter1-Unix-基础知识" class="headerlink" title="Chapter1 Unix 基础知识"></a>Chapter1 Unix 基础知识</h1><ol>
<li>登录名<br>在’’’ /etc/passwd ‘’’ 文件中可以看见登录名</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hallwood:xxxx:1000:1000:hallwood zhang:/home/hallwood:/bin/zsh</span><br></pre></td></tr></table></figure>
<p>他具有这样的格式，用7个冒号作出八个分段，分别是</p>
<table>
<thead>
<tr>
<th>登录名</th>
<th>加密口令</th>
<th>数字用户ID</th>
<th>数字组id</th>
<th>注释字段</th>
<th>起始目录</th>
<th>对应shell程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>hallwood</td>
<td>xxxx</td>
<td>1000</td>
<td>1000</td>
<td>hallwood zhang</td>
<td>/home/hallwood</td>
<td>/bin/zsh</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>shell</li>
</ol>
<p>读取用户输入并且执行相对应指令的解释性脚本处理和解析器</p>
<ol start="3">
<li>文件系统</li>
</ol>
<p>‘/‘ 是根目录的位置，也是他的名字</p>
<p><strong>目录</strong> 是包含 <strong>目录项</strong> 的 <strong>文件</strong></p>
<p><strong>目录项</strong> 包含 <strong>文件名</strong> ，同时包含 <strong>文件属性</strong> 的信息</p>
<p><strong>文件属性</strong>  包含 <strong>文件类型</strong> ， <strong>文件长度</strong>, <strong>文件所有者</strong>, <strong>文件的许可权</strong>, <strong>文件最后的修改时间</strong> 等信息。</p>
<p>不能出现在文件名中的字符只有两个,斜线 (/)和空操作符(null)</p>
<p>当创建一个新目录时,自动创建了两个文件名: . (称为点)和.. (称为点-点)。点引用当前目录,点-点则引用父目录。在最高层次的根目录中,点 -点与点相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 程序1_1.c 列出一个目录中的所有文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ourhdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        err_quit(<span class="string">"a single argument (the directory name is required!)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( (dirp = readdir(dp)) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用下列命令可以看到大多数场景中ls的用法<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 1 ls</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">learning_unix ➤ touch Makefile                                                                            git:master*</span><br><span class="line">learning_unix ➤ cc 1_1.c                                                                                  git:master*</span><br><span class="line">learning_unix ➤ ls                                                                                        git:master*</span><br><span class="line">1_1.c  a.out  errhandler.c  Makefile  ourhdr.h</span><br><span class="line">learning_unix ➤ a.out /dev                                                                                git:master*</span><br><span class="line">zsh: command not found: a.out</span><br><span class="line">learning_unix ➤ ./a.out /dev                                                                              git:master*</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">watchdog1</span><br><span class="line">vcsa6</span><br><span class="line">vcsu6</span><br><span class="line">vcs6</span><br><span class="line">vcsa5</span><br><span class="line">vcsu5</span><br><span class="line">vcs5</span><br><span class="line">vcsa4</span><br><span class="line">vcsu4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 以下省略</span><br></pre></td></tr></table></figure>
<p>以上就是程序1_1的执行结果，相当于实现了一个简单的ls</p>
<ol start="4">
<li>输入和输出</li>
</ol>
<p><strong>文件描述符</strong> 是一个小的 <strong>非负整数</strong>，kernel用这个整数来标记一个 <strong>特定的进程访问的文件</strong>， 当内核打开一个现存的文件或者新建一个文件的时候，就会返回一个文件描述符</p>
<p>每当运行一个新程序的时候，所有的shell就会为其打开三个文件描述符：<strong>标准输入，标准输出，标准出错</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 比如通过重定向标准输出，生成一个log文件</span><br><span class="line">ls /path &gt; file.list</span><br></pre></td></tr></table></figure>
<p>一般的，函数open, read, write, lseek还有close函数都提供了不用缓存的IO功能，这些函数都使用文件描述符工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 程序1_2.c 将标准输入复制到标准输出 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ourhdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="keyword">while</span>( (n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(write(STDOUT_FILENO, buf, n) != n) &#123;</span><br><span class="line">            err_sys(<span class="string">"write err"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">"read err"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序简单地将标准输入的东西转化到标准输出并且写入到输出流中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 程序1_3.c 用标准IO将标准输入写到标准输出上 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ourhdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>( (c = getc(<span class="built_in">stdin</span>)) != EOF ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(putc(c, <span class="built_in">stdout</span>) == EOF) &#123;</span><br><span class="line">            err_sys(<span class="string">"write err"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ferror(<span class="built_in">stdin</span>)) &#123;</span><br><span class="line">        err_sys(<span class="string">"read err"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述个函数的实现方式略有差异，一个是使用缓存的方式，一个是逐个字符扫描的方式。</p>
<ol start="5">
<li>程序与进程</li>
</ol>
<p>程序是存放在硬盘中的可执行的文件，使用unix中提供的六个exec接口可以执行，将程序加载入ram或者主存的工作由内核完成</p>
<p>每一个unix进程都有一个唯一的标志，这个被称之为 <strong>process id</strong>，它是一个唯一的非负整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 程序1_4: 用来打印某个程序的pid */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ourhdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于进程控制，有三个主要用于进程控制的函数，分别是 <strong>fork、exec和waitpid</strong>（exec函数有6种变体，统一称为exec函数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 程序1_5.c 从标准输入读入命令并且执行 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ourhdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">if</span>( (pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err_sys(<span class="string">"fork err"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span>*) <span class="number">0</span>);</span><br><span class="line">            err_ret(<span class="string">"couldnt exec: %c"</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            err_sys(<span class="string">"waitpid err"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/NLPDemo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/23/NLPDemo/" class="post-title-link" itemprop="url">NLPDemo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-23 17:58:38" itemprop="dateCreated datePublished" datetime="2019-04-23T17:58:38+08:00">2019-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NLP情感分析的一个简单demo"><a href="#NLP情感分析的一个简单demo" class="headerlink" title="NLP情感分析的一个简单demo"></a>NLP情感分析的一个简单demo</h1><ul>
<li><p>by <a href="mailto:hallwoodzhang@gmail.com" target="_blank" rel="noopener">hallwoodzhang@gmail.com</a></p>
</li>
<li><p>在实验开始前，先要保证电脑中具有</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">numpy</span><br><span class="line">jieba</span><br><span class="line">gensim</span><br><span class="line">matplotlib</span><br><span class="line">scikit-learn</span><br><span class="line"></span><br><span class="line">tensorflow</span><br><span class="line">keras</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有这个你也很不舒服对吧，这个必须有</span></span><br><span class="line">jupyter-notebook</span><br></pre></td></tr></table></figure>
<ul>
<li><p>由于我的os是Arch Linux这些package的安装非常方便，不是pacman就是makepkg，如果是其他Linux发行版或者是mac更有甚者使用windows的同学，安装过程可能会复杂一些</p>
</li>
<li><p>这个实验的规模很小，所以并没有使用GPU来进行cuda加速，直接使用老旧的i5-3320M作为运算承担者，也不是很烫手</p>
</li>
<li><p>在实验之前，需要先下载知乎的词料库，这个词料库是由北京师范大学和中国人民大学的 DBIIR 实验室的研究者开源和免费提供的”chinese-word-vectors”，非常感谢这些老师和同学的努力，这里给出他们的github repo地址（自觉star）还有需要的百度云地址：</p>
</li>
</ul>
<p><a href="https://github.com/Embedding/Chinese-Word-Vectors" target="_blank" rel="noopener">https://github.com/Embedding/Chinese-Word-Vectors</a></p>
<p><a href="https://pan.baidu.com/s/1OQ6fQLCgqT43WTwh5fh_lg" target="_blank" rel="noopener">https://pan.baidu.com/s/1OQ6fQLCgqT43WTwh5fh_lg</a></p>
<p>如果嫌下载速度慢，作为一个程序员，我建议你使用baidu_pcs_go，具体怎么使用自行在github查找，使用时也请自觉star</p>
<ul>
<li><p>如果你不知道什么是word2vec，也没有关系，你只需要知道他是一种词语转化为一维向量的一种压缩表示，并且意义相近或者出现相近频率高的两个词所转化的一维向量之中他们的cos值非常接近 1,距离非常近，就行了，具体的预处理细节（预处理过程也是一次深度学习过程）与本实验无关</p>
</li>
<li><p>我通过一个github用户aespresso，和他发布的youtube教程找到了这个repo，不仅如此，我这一整个实验也是基于这位先生的教程，非常感谢他无私的奉献</p>
</li>
</ul>
<p><strong>这个是他的github repo:</strong><br><a href="https://github.com/aespresso/chinese_sentiment" target="_blank" rel="noopener">https://github.com/aespresso/chinese_sentiment</a></p>
<p><strong>这个是我在youtube找到的教程的地址</strong><br><a href="https://www.youtube.com/watch?v=-mcrmLmNOXA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=-mcrmLmNOXA</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先，我们需要先导入特定的需要的模块，并且确定utf-8编码</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> KeyedVectors</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后, 我们需要使用gensim中的模块导入系统导入知乎的向量库，这个向量库是经过</span></span><br><span class="line"><span class="comment"># 别的dalao训练过的词向量模型，这是一个很帅气的预处理工作，它生成了一个名字-&gt;长度为300的向量的字典</span></span><br><span class="line"></span><br><span class="line">cn_model = KeyedVectors.load_word2vec_format(<span class="string">"./sgns.zhihu.bigram"</span>, binary=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">embedding_dim = cn_model[<span class="string">"东北大学"</span>].shape[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">"词向量的长度是：&#123;&#125;"</span>.format(embedding_dim))</span><br><span class="line">print(cn_model[<span class="string">'东北大学'</span>])</span><br></pre></td></tr></table></figure>
<pre><code>词向量的长度是：300
[-0.173169  0.167039 -0.280759 -0.014771 -0.383082 -0.449514  0.004122
  0.181255 -0.0816    0.166133 -0.422213  0.61386   0.200546 -0.047912
  0.521156 -0.452226  0.205978  0.310417  0.271675  0.188779  0.056854
  0.248341 -0.250261  0.016247 -0.278753 -0.346694 -0.03471   0.03249
  0.215906  0.094957 -0.052379  0.135054 -0.565997  0.116935 -0.033103
  0.063923  0.063995 -0.047387 -0.147508  0.04383  -0.710059 -0.238688
 -0.420966  0.104801  0.036028  0.015015 -0.076793  0.109947 -0.117651
  0.240857  0.046658 -0.506142  0.193275 -0.262593 -0.223561  0.084296
 -0.40914   0.353332  0.036367  0.244455  0.190103  0.45901  -0.095526
 -0.031275  0.179822 -0.009634 -0.119463  0.182669  0.251691  0.163992
 -0.162786 -0.067089 -0.367855 -0.453598 -0.114575 -0.090093  0.22609
  0.084055 -0.008024  0.116842  0.245771 -0.079714 -0.21936   0.158594
 -0.147824 -0.007306  0.038464  0.076449  0.010872  0.339708 -0.387843
  0.070963 -0.162495 -0.055928 -0.014498 -0.3011   -0.006571 -0.170685
  0.249473  0.395145  0.490381  0.439393  0.070372  0.204143 -0.357806
  0.346742  0.114885  0.051335  0.227703 -0.269376 -0.230159  0.628753
  0.454348  0.303936 -0.309634  0.044038 -0.072019  0.121463 -0.387852
  0.11073   0.319537  0.319746  0.129916 -0.45686  -0.065263 -0.327417
 -0.239647 -0.129028  0.28914  -0.228613  0.466321  0.210633  0.37147
  0.12168   0.340034 -0.333509  0.086691  0.077145 -0.094515 -0.043243
 -0.310047  0.200959 -0.092351 -0.342879 -0.478685 -0.066384  0.163397
  0.857368 -0.080743  0.169016  0.09662  -0.123794 -0.117578 -0.26009
  0.795876  0.789666  0.069576 -0.133995 -0.042939  0.082372  0.001277
  0.108221 -0.627131 -0.201711  0.283772 -0.112421 -0.411831  0.246149
  0.450343 -0.018889 -0.217646  0.085195 -0.093665  0.121886  0.041374
 -0.154509 -0.475513  0.414564 -0.632025 -0.001257 -0.143076  0.076735
  0.232488  0.28378   0.060433  0.059984 -0.113402  0.10065  -0.130145
  0.450837 -0.52761   0.039118 -0.237067 -0.19011  -0.013432 -0.288856
 -0.044987 -0.10847  -0.046629  0.035354  0.455324  0.067548  0.214632
 -0.196388  0.765769  0.199199 -0.030234 -0.058608  0.036483 -0.082312
 -0.228086 -0.275695 -0.281059 -0.364453  0.045814  0.43929   0.142706
 -0.021881 -0.05454   0.430346  0.052213  0.437351  0.170989 -0.175498
  0.439948 -0.438312  0.002475  0.370412  0.070516 -0.206736  0.016968
 -0.11588  -0.117777 -0.148206 -0.059988  0.030804 -0.04045   0.324203
  0.234363  0.128853 -0.202953  0.0302    0.244632  0.161924  0.037215
  0.259181 -0.149307 -0.633232  0.096391  0.274292  0.36863  -0.263364
 -0.03885   0.320316  0.166729 -0.079096  0.226739 -0.272492  0.15599
  0.218765  0.136066 -0.428375 -0.19812   0.198432 -0.594367 -0.305591
  0.047796 -0.323848 -0.202678  0.293873  0.328747 -0.647988  0.068186
  0.26757   0.435469  0.22514  -0.006098  0.110309  0.494696 -0.267628
  0.150945  0.015826  0.114192  0.039815  0.067472  0.280086 -0.190843
 -0.274264  0.206202 -0.30322  -0.264427 -0.298466 -0.561606 -0.21909
 -0.05875  -0.137941  0.081865  0.271779  0.574957 -0.519857]
</code></pre><p>很显然，这一步我们直接跳过了一个步骤，那就是将中文词汇转化为vector的步骤，完成这个步骤的dalao帮助我们省了很多事情，所以我们有更多的精力用来构造双向LSTM模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我现在尝试了解KeyedVectors.load_word2vec_format("./sgns.zhihu.bigram", binary=False)</span></span><br><span class="line"><span class="comment"># 的返回值的（也就是词向量字典封装类）结构，在这里我们给它赋值为cn_model，如上所示</span></span><br><span class="line"></span><br><span class="line">print(dir(cn_model))</span><br><span class="line">print(type(cn_model))</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_adapt_by_suffix&apos;, &apos;_load_specials&apos;, &apos;_log_evaluate_word_analogies&apos;, &apos;_save_specials&apos;, &apos;_smart_save&apos;, &apos;accuracy&apos;, &apos;add&apos;, &apos;closer_than&apos;, &apos;cosine_similarities&apos;, &apos;distance&apos;, &apos;distances&apos;, &apos;doesnt_match&apos;, &apos;evaluate_word_analogies&apos;, &apos;evaluate_word_pairs&apos;, &apos;get_keras_embedding&apos;, &apos;get_vector&apos;, &apos;index2entity&apos;, &apos;index2word&apos;, &apos;init_sims&apos;, &apos;load&apos;, &apos;load_word2vec_format&apos;, &apos;log_accuracy&apos;, &apos;log_evaluate_word_pairs&apos;, &apos;most_similar&apos;, &apos;most_similar_cosmul&apos;, &apos;most_similar_to_given&apos;, &apos;n_similarity&apos;, &apos;rank&apos;, &apos;relative_cosine_similarity&apos;, &apos;save&apos;, &apos;save_word2vec_format&apos;, &apos;similar_by_vector&apos;, &apos;similar_by_word&apos;, &apos;similarity&apos;, &apos;similarity_matrix&apos;, &apos;syn0&apos;, &apos;syn0norm&apos;, &apos;vector_size&apos;, &apos;vectors&apos;, &apos;vectors_norm&apos;, &apos;vocab&apos;, &apos;wmdistance&apos;, &apos;word_vec&apos;, &apos;words_closer_than&apos;, &apos;wv&apos;]
&lt;class &apos;gensim.models.keyedvectors.Word2VecKeyedVectors&apos;&gt;
</code></pre><p>在这里，我们使用了dir函数，它炸出了一大堆东西，但是我菜啊，我看不懂，怎么办</p>
<p>只能根据这些输出的函数名字去分别了解相对应的功能，使用google，事半功倍</p>
<p><strong>我们可以很容易地找到，gensim的doc网址</strong><br><a href="https://radimrehurek.com/gensim/apiref.html" target="_blank" rel="noopener">https://radimrehurek.com/gensim/apiref.html</a></p>
<p>这样我们就可以知道KeyedVectors.load_word2vec_format这个载入函数的返回值的类型了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class 'gensim.models.keyedvectors.Word2VecKeyedVectors'&gt;</span><br></pre></td></tr></table></figure>
<p>哇，这个是什么类？我们可以用这个类做什么？这个直接在官方的文档网站就可以找到</p>
<ul>
<li>Mapping between words and vectors for the Word2Vec model. Used to perform operations on the vectors such as vector lookup, distance, similarity etc.</li>
</ul>
<p>这样，这个类的对象是一个字典类似对象，但是给出了很多方便的接口，比如计算两个词之间的相似度，距离等等非常方便的接口<br>我们接下来马上试试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出最相近的词，我们比较贪心，要找出前100个相似的，这里用的向量余弦相似度，属于高中数学内容</span></span><br><span class="line">cn_model.most_similar(positive=[<span class="string">'大学'</span>], topn=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[(&apos;高中&apos;, 0.7247821688652039),
 (&apos;本科&apos;, 0.6768536567687988),
 (&apos;研究生&apos;, 0.6244412660598755),
 (&apos;中学&apos;, 0.6088206768035889),
 (&apos;大学本科&apos;, 0.595908522605896),
 (&apos;初中&apos;, 0.5883588790893555),
 (&apos;读研&apos;, 0.5778335928916931),
 (&apos;职高&apos;, 0.5767994523048401),
 (&apos;大学毕业&apos;, 0.5767452120780945),
 (&apos;师范大学&apos;, 0.5708829164505005),
 (&apos;职中&apos;, 0.5695523023605347),
 (&apos;医科&apos;, 0.5680999159812927),
 (&apos;医学院&apos;, 0.5679919123649597),
 (&apos;小学&apos;, 0.5646480321884155),
 (&apos;中专&apos;, 0.5628771185874939),
 (&apos;预科&apos;, 0.5617093443870544),
 (&apos;高中后&apos;, 0.561117947101593),
 (&apos;专科学校&apos;, 0.5603978037834167),
 (&apos;医学院校&apos;, 0.5599128603935242),
 (&apos;高中上&apos;, 0.5595210194587708),
 (&apos;高中和&apos;, 0.5583246350288391),
 (&apos;高中没&apos;, 0.5544076561927795),
 (&apos;高中都&apos;, 0.5528644919395447),
 (&apos;军校&apos;, 0.5500032305717468),
 (&apos;技校&apos;, 0.548747718334198),
 (&apos;庆应&apos;, 0.5458650588989258),
 (&apos;念书&apos;, 0.5458193421363831),
 (&apos;高校&apos;, 0.5448956489562988),
 (&apos;那所&apos;, 0.5438604950904846),
 (&apos;野鸡大学&apos;, 0.542473554611206),
 (&apos;法学院&apos;, 0.5421650409698486),
 (&apos;职校&apos;, 0.5418159365653992),
 (&apos;硕士&apos;, 0.5406658053398132),
 (&apos;高中再&apos;, 0.5402267575263977),
 (&apos;私立高中&apos;, 0.5399061441421509),
 (&apos;高中我&apos;, 0.5386292934417725),
 (&apos;国际部&apos;, 0.5384584665298462),
 (&apos;大专&apos;, 0.5383963584899902),
 (&apos;普高&apos;, 0.5363925695419312),
 (&apos;高中里&apos;, 0.5352319478988647),
 (&apos;重点高中&apos;, 0.5320777893066406),
 (&apos;武汉一&apos;, 0.5320106148719788),
 (&apos;普通本科&apos;, 0.5314226150512695),
 (&apos;私立中学&apos;, 0.5313701629638672),
 (&apos;名牌大学&apos;, 0.5307841897010803),
 (&apos;卫校&apos;, 0.530119001865387),
 (&apos;高中到&apos;, 0.5297942161560059),
 (&apos;985&apos;, 0.5292823910713196),
 (&apos;师范院校&apos;, 0.5284144282341003),
 (&apos;艺校&apos;, 0.5281397104263306),
 (&apos;师范类&apos;, 0.5281273126602173),
 (&apos;普通高中&apos;, 0.5267952084541321),
 (&apos;师范&apos;, 0.5257189869880676),
 (&apos;警校&apos;, 0.5256354212760925),
 (&apos;师范学校&apos;, 0.5255476832389832),
 (&apos;学校&apos;, 0.5252041220664978),
 (&apos;高三没&apos;, 0.5238454937934875),
 (&apos;大连理工&apos;, 0.5235210061073303),
 (&apos;院校&apos;, 0.5231703519821167),
 (&apos;艺术院校&apos;, 0.5229425430297852),
 (&apos;军医大&apos;, 0.5211274027824402),
 (&apos;外国语大学&apos;, 0.5209094285964966),
 (&apos;英语系&apos;, 0.5208790302276611),
 (&apos;社区大学&apos;, 0.5202288627624512),
 (&apos;高中又&apos;, 0.5201476812362671),
 (&apos;五年制&apos;, 0.5199419856071472),
 (&apos;省级重点&apos;, 0.5197730660438538),
 (&apos;军医大学&apos;, 0.519767165184021),
 (&apos;金融系&apos;, 0.5196066498756409),
 (&apos;师范学院&apos;, 0.5194557309150696),
 (&apos;职业学院&apos;, 0.518003523349762),
 (&apos;公立大学&apos;, 0.5172786712646484),
 (&apos;普通高校&apos;, 0.5172494053840637),
 (&apos;外国语学院&apos;, 0.5171521902084351),
 (&apos;财经学校&apos;, 0.5170426964759827),
 (&apos;高中考&apos;, 0.5167708396911621),
 (&apos;高中在&apos;, 0.5163607001304626),
 (&apos;211&apos;, 0.5148729085922241),
 (&apos;名校&apos;, 0.5147680044174194),
 (&apos;北大医学部&apos;, 0.5146102905273438),
 (&apos;师专&apos;, 0.5141969919204712),
 (&apos;寄宿制&apos;, 0.5140889883041382),
 (&apos;武汉某&apos;, 0.5136144757270813),
 (&apos;某大学&apos;, 0.5126028060913086),
 (&apos;川大&apos;, 0.5104366540908813),
 (&apos;日语系&apos;, 0.5104085206985474),
 (&apos;毛中&apos;, 0.510360836982727),
 (&apos;初高中&apos;, 0.5103123784065247),
 (&apos;成人高考&apos;, 0.510170578956604),
 (&apos;高三后&apos;, 0.5100051760673523),
 (&apos;九八五&apos;, 0.5088520646095276),
 (&apos;法律系&apos;, 0.5087538957595825),
 (&apos;美国大学&apos;, 0.5084203481674194),
 (&apos;工科大学&apos;, 0.5082870721817017),
 (&apos;数学系&apos;, 0.5082342624664307),
 (&apos;艺术学校&apos;, 0.5080037117004395),
 (&apos;考上&apos;, 0.50799161195755),
 (&apos;继续教育&apos;, 0.5068403482437134),
 (&apos;高中当&apos;, 0.5067394971847534),
 (&apos;南外&apos;, 0.5065196752548218)]
</code></pre><p>可以很容易的看出，后面的相似度是用一个很长的浮点数来表示的，这表示越接近1,两个词之间越相似，可以说这个预训练的词向量集合还是比较靠谱的，基本上不会出现相似度非常高，但是风马牛不相及的词</p>
<p>我们可以使用自己的词语来测试一下，这个model中能不能挑出一组词中的“异类”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_words = <span class="string">"老师 会计 程序员 律师 医生 老人"</span></span><br><span class="line">diff_word = cn_model.doesnt_match(test_words.split())</span><br><span class="line">print(<span class="string">'在 '</span> + test_words + <span class="string">' 中:\n不是同一类别的词为: %s'</span> % diff_word)</span><br></pre></td></tr></table></figure>
<pre><code>在 老师 会计 程序员 律师 医生 老人 中:
不是同一类别的词为: 老人
</code></pre><p>我们可以很容易的看到，这个模型的很容易的从一堆职业表示词中挑选出了一个表示某一个年龄的人群的词</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cn_model.most_similar(positive=[<span class="string">'女人'</span>,<span class="string">'出轨'</span>], negative=[<span class="string">'男人'</span>], topn=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[(&apos;劈腿&apos;, 0.5849197506904602),
 (&apos;婚外情&apos;, 0.5557920336723328),
 (&apos;偷情&apos;, 0.5555664896965027),
 (&apos;外遇&apos;, 0.545864462852478),
 (&apos;再婚&apos;, 0.5422407388687134),
 (&apos;未婚先孕&apos;, 0.5357396006584167),
 (&apos;隐婚&apos;, 0.5257365107536316),
 (&apos;离婚&apos;, 0.5245394110679626),
 (&apos;马蓉&apos;, 0.5239366292953491),
 (&apos;通奸&apos;, 0.522205650806427)]
</code></pre><p>在这里，我们要从词料库中挑选出最接近“女人”，“出轨”这两个词的词，但是这些词我们希望和“男人”这个词关系尽量远，就这样筛选出了上述十个词</p>
<p>居然出现了“马蓉”小姐，这个也太真实了吧，我哭了<br>那要是我们换一种玩法，使用“男人”，“出轨”，作为正向的引导，反之要求和“女人”这个词距离远一点结果会怎么样呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cn_model.most_similar(positive=[<span class="string">'男人'</span>,<span class="string">'出轨'</span>], negative=[<span class="string">'女人'</span>], topn=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[(&apos;劈腿&apos;, 0.6062113046646118),
 (&apos;外遇&apos;, 0.558462381362915),
 (&apos;婚外情&apos;, 0.5538169741630554),
 (&apos;马蓉&apos;, 0.5418684482574463),
 (&apos;隐婚&apos;, 0.5396678447723389),
 (&apos;嫖娼&apos;, 0.5364097952842712),
 (&apos;移情别恋&apos;, 0.5359160900115967),
 (&apos;偷情&apos;, 0.5289183259010315),
 (&apos;骗婚&apos;, 0.5087193846702576),
 (&apos;好男人&apos;, 0.5070855617523193)]
</code></pre><p>居然出现了“好男人”这个词，笑死我了（马某人又是你，这说明在知乎，马某人和出轨这种话题共同出现的频率非常高</p>
<p>值得注意的是，这里的所有列出来的值都很接近百分之50,说明预处理词向量的model并不是很确定它的决定是否准确，所以我们观察到这两次的“出轨”相关的输出相差不是很大，事实上，就算是人类自己来做这种分类，也很难说“劈腿”到底是更像“女人”，还是更像“男人”，但是“未婚先孕”一定是更像“女人”的，这点也在上面的两次输出中体现出来了</p>
<p>这个确实很好玩，有兴趣的可以想想有什么新的玩法</p>
<p><strong>通过现有的经过预处理的model来猜测一些评价的倾向</strong></p>
<p>因为我比较菜，所以这里做的工作仅限于区分正面评价和负面评价，并且给定一个概率值来表示生成的model对于这个结果的确信程度</p>
<p>在这里，我找到了网上的一些资料作为训练集，用来训练我们自己的微型人工智障</p>
<p>并且用生成的model去猜测一些评价的积极性，在这里我使用LSTM模型，并且使用双向的模型</p>
<p>那么问题来了，我去那里找评价？爬虫爬？这个工程量有点大，我时间比较有限，所以这里使用哈工大谭松波老师的数据集</p>
<p>这个数据集很难找，<strong>所以我通过一个github用户aespresso，和他发布的youtube教程找到了这个repo，不仅如此，我这一整个实验也是基于这位先生的教程，非常感谢他无私的奉献</strong></p>
<p><strong>这个是他的github repo:</strong><br><a href="https://github.com/aespresso/chinese_sentiment" target="_blank" rel="noopener">https://github.com/aespresso/chinese_sentiment</a></p>
<p>直接给star！有什么好说的？</p>
<p><strong>这个是我在youtube找到的教程的地址</strong><br><a href="https://www.youtube.com/watch?v=-mcrmLmNOXA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=-mcrmLmNOXA</a></p>
<p>我在这个repo中找到了现成的已经经过分类的好评和差评的集合，现在我们把它导入进来，并且作为我们的训练集还有测试集，这时候我们距离我们的第一个人工智障又进了一步</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在，我们需要导入评价集</span></span><br><span class="line"><span class="comment"># 这个path由你自己定义，我在这里直接clone了aespresso的repo所以path是</span></span><br><span class="line"><span class="comment"># ./chinese_sentiment/pos和./chinese_sentiment/neg</span></span><br><span class="line"><span class="comment"># 记得unzip 语料.zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">positive_dir = os.listdir(<span class="string">"./chinese_sentiment/pos"</span>)</span><br><span class="line">negative_dir = os.listdir(<span class="string">"./chinese_sentiment/neg"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(type(positive_dir))</span><br><span class="line">print(len(positive_dir))</span><br><span class="line"><span class="comment"># print(positive_dir)</span></span><br><span class="line">print(<span class="string">'样本总共: '</span>+ str(len(negative_dir) + len(positive_dir)))</span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;list&apos;&gt;
2000
样本总共: 4000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接下来我们会一步步把所有的评论都放在一个list内，并且打乱他们，尝试分出</span></span><br><span class="line"><span class="comment"># 用来训练的和测试的部分集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function </span><br><span class="line"></span><br><span class="line">origin_train_txts = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这么频繁的文件IO操作可能会有点慢，而且有点卡</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(positive_dir)):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./chinese_sentiment/pos/"</span> + positive_dir[i], <span class="string">"r"</span>, errors=<span class="string">"ignore"</span>, encoding=<span class="string">"gbk"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        text = f.read().strip()</span><br><span class="line">        origin_train_txts.append(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(negative_dir)):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./chinese_sentiment/neg/"</span> + negative_dir[i], <span class="string">"r"</span>, errors=<span class="string">"ignore"</span>, encoding=<span class="string">"gbk"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        text = f.read().strip()</span><br><span class="line">        origin_train_txts.append(text)</span><br><span class="line"></span><br><span class="line">print(type(origin_train_txts))</span><br><span class="line">print(len(origin_train_txts))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 怎么回事，居然有乱码。。。。真是奇葩</span></span><br><span class="line"><span class="comment"># 这里有点坑爹，原来的文件是gb 2312编码</span></span><br><span class="line"><span class="comment"># 都9102年了，90后都要奔三了，utf-8居然还没有普及，惊了</span></span><br><span class="line">print(origin_train_txts[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;list&apos;&gt;
4000
单人间的价格物超所值.早餐不错.服务也好,很人性化.呵呵,第一次碰到卫生间马桶里撒花瓣的宾馆.不过酒店的洗浴中心,美容美发都在装修中不能使用.预定时没有提到.
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用核武器tensorflow和傻瓜式接口keras</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.layers <span class="keyword">import</span> Dense, GRU, Embedding, LSTM, Bidirectional</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.preprocessing.text <span class="keyword">import</span> Tokenizer</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.optimizers <span class="keyword">import</span> RMSprop</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.callbacks <span class="keyword">import</span> EarlyStopping, ModelCheckpoint, TensorBoard, ReduceLROnPlateau</span><br></pre></td></tr></table></figure>
<p><strong>分词和tokenize</strong></p>
<p>首先我们去掉每个样本的标点符号，然后用jieba这个库分词，jieba分词返回一个生成器，没法直接进行tokenize，所以我们将分词结果转换成一个list，并将它索引化，这样每一例评价的文本变成一段索引数字，对应着预训练词向量模型中的词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行分词和tokenize</span></span><br><span class="line"><span class="comment"># train_tokens是一个长长的list，其中含有4000个小list，对应每一条评价</span></span><br><span class="line"></span><br><span class="line">train_tokens = []</span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> origin_train_txts:</span><br><span class="line">    <span class="comment"># 去掉标点</span></span><br><span class="line">    text = re.sub(<span class="string">"[\s+\.\!\/_,$%^*(+\"\']+|[+——！，。？、~@#￥%……&amp;*（）]+"</span>, <span class="string">""</span>, text)</span><br><span class="line">    <span class="comment"># 结巴分词</span></span><br><span class="line">    cut = jieba.cut(text)</span><br><span class="line">    cut_list = [ i <span class="keyword">for</span> i <span class="keyword">in</span> cut ]</span><br><span class="line">    <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(cut_list):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 将词转换为索引index</span></span><br><span class="line">            cut_list[i] = cn_model.vocab[word].index</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># 如果词不在字典中，则输出0</span></span><br><span class="line">            cut_list[i] = <span class="number">0</span></span><br><span class="line">    train_tokens.append(cut_list)</span><br><span class="line"></span><br><span class="line">print(len(train_tokens))</span><br><span class="line">print(train_tokens[<span class="number">0</span>:<span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<pre><code>Building prefix dict from the default dictionary ...
Dumping model to file cache /tmp/jieba.cache
Loading model cost 1.198 seconds.
Prefix dict has been built succesfully.


4000
[[0, 1, 651, 66551, 4656, 562, 1191, 1562, 34, 13758, 2012, 0, 2020, 6296, 6729, 63, 3649, 15627, 1, 7224, 223, 1845, 1, 38926, 1486, 107489, 11, 15, 3783, 60, 124, 308, 10395, 100, 29, 872], [7224, 15, 95, 5976, 24, 31233, 173, 67, 2380, 497, 9074, 5139, 87, 7224, 5249, 103, 1113, 1, 869, 1487, 2871, 333, 470, 95, 67, 879, 83986, 1321, 57, 0, 0, 1, 110, 578, 562, 38, 15, 95, 9081, 457, 2567, 10199, 11216, 0, 148, 148, 2360, 2360, 7215, 158, 893, 1426, 38, 1353, 7224, 2289, 9265, 388, 0, 38, 35, 48, 44101, 33287, 810, 115835, 95, 9081, 10984, 1117, 0, 147, 3466, 562, 657, 51, 6781, 1622, 1, 62779, 211, 169, 9852, 1256, 88407, 87], [40, 562, 25, 310, 614, 0, 2852, 38, 72, 3, 66, 1845, 4, 8, 119, 1487, 7261, 1, 10, 56, 183, 14862, 10, 614], [1105, 29184, 34, 562, 949, 18, 34, 72, 38, 15, 46465, 2001, 1175, 366, 48, 46465, 0, 175, 1419, 3365, 34, 7314], [6247, 3, 7, 1487, 659, 3, 0, 7723, 237, 67, 4429, 40, 640, 1038], [2004, 3, 0, 774, 2852, 3930, 40, 2813, 4656, 40, 562, 8241, 1191, 18, 562], [82, 135465, 24, 130, 138, 39, 44289, 9512, 1, 1191, 779, 34, 236, 27, 190, 517, 161, 21119, 48, 7227, 49095, 3819, 11780, 95173, 11780, 384, 123, 9819, 2657, 51127, 35, 16, 15, 27, 659, 64, 1, 7224, 63, 1191, 4, 5044, 1, 8, 0, 627, 55, 6, 34, 1896, 274, 32739, 6582, 65110, 5, 4305, 63441, 9917, 1366, 6, 8, 27180, 312, 15, 62631, 100, 1886, 6, 4225, 6, 3306, 136, 482, 29406, 16, 242, 116, 0, 35, 748, 110892, 6, 233, 116, 12961, 484, 11, 3069, 51, 6, 2733, 41, 84749, 27, 48, 7227, 1, 1138, 39039, 69612, 2922, 209, 598, 27, 509, 1487, 15, 1487, 63, 2042, 3, 11780, 8705, 13, 15, 8633, 100, 130, 6, 61858, 24, 10254, 48234, 1304, 55, 15370, 4305, 51, 6, 9475, 2953, 57714, 9686, 309, 4026, 88, 4305, 18, 760, 48, 6, 2737, 26572, 70, 51, 3, 0, 48234, 6, 1212, 84, 275, 14684, 6, 8, 12451, 63634, 509, 3, 2437, 2852, 38, 8649, 15565, 4305, 1184, 51, 6, 62993, 241490, 4026, 88, 4305, 70, 3306, 8649, 25862, 6, 7820, 84, 1304, 20760, 15370, 4305, 412, 15, 27, 5916, 84, 2878, 1487, 484, 569, 1487, 412, 23083, 1, 366, 40, 9475, 2595, 22, 399, 27, 4819, 1645, 82, 29, 653, 64, 1, 3507, 27, 3332, 1845, 1340, 1, 1536, 11, 2564, 7124, 55, 12, 1044, 34, 7869, 6, 40, 760, 48, 1845, 614, 1, 4656, 1604, 51, 1487, 598, 1, 2730, 5, 95, 19067, 832, 11, 169, 72, 213, 22, 357, 11, 778, 1845, 13675, 1112, 56203, 44, 133, 46, 1, 1536, 1755, 117, 532, 0, 55, 79, 7179, 4910, 11620, 3563, 614, 13758, 1191, 33216, 2643, 7060, 27396, 22, 4, 34, 10, 374, 1, 168, 293, 19888, 1845, 95173, 4652, 127, 10, 34, 1616, 86, 79, 40494, 1, 1191, 1703, 1623, 3, 4910, 27, 4952, 49095, 57, 11641, 7227, 48, 7227, 62554, 338, 57, 11641, 44289, 9512], [949, 5249, 11, 562, 651, 18, 40, 35, 25, 21604, 5915, 3, 33, 1872, 5020, 3, 41, 366], [3930, 246, 40, 562, 3365, 1191, 11, 7347, 1845, 348, 2158, 3, 2732, 7723, 0, 0, 1, 15565, 34, 2495, 2012, 4429, 40, 9483, 88], [1162, 11780, 44289, 9512, 44512, 0, 7869, 1845, 1536, 2643, 21531, 1191, 57, 96, 1, 5593, 6, 11780, 64, 1, 18369, 221, 0, 0, 1845, 81, 107, 1527, 1191, 10, 15, 7, 7723, 829, 9153, 9512, 333, 562, 2694, 6, 57, 30, 11780, 0, 856, 1, 2497, 4, 158579, 2437, 0, 26782, 1191, 124, 15, 135, 228, 18881, 11276, 276, 455, 5166]]
</code></pre><p>从上面的结果我们很容易就可以看出来，很多词是无法从知乎的语料库中找到相对应的索引的，除此之外，更加严重的问题是，每一个文本评价(句子)-&gt;index list，这个过程中由于每个句子不同，所以我们很容易看到这些index list的长度是不一样的，这不利于我们接下来深度学习的模型构造</p>
<p>所以我们需要把所有的index list填充成为相同长度的index list并且用无效索引0作为填充值，往前面填充0,或者往尾部填充0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得所有tokens的长度</span></span><br><span class="line">num_tokens = [ len(tokens) <span class="keyword">for</span> tokens <span class="keyword">in</span> train_tokens ]</span><br><span class="line">num_tokens = np.array(num_tokens)</span><br><span class="line"></span><br><span class="line">print(num_tokens[<span class="number">0</span> : <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"平均tokens的长度"</span> + str(np.mean(num_tokens)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"最长tokens的长度"</span> + str(np.max(num_tokens)))</span><br></pre></td></tr></table></figure>
<pre><code>[ 36  86  24  22  14  15 317  18  25  62]
平均tokens的长度71.4495
最长tokens的长度1540
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在这里我们需要了解长度分布情况</span></span><br><span class="line"></span><br><span class="line">plt.hist(np.log(num_tokens), bins = <span class="number">100</span>)</span><br><span class="line">plt.xlim((<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line">plt.ylabel(<span class="string">'number of tokens'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'length of tokens'</span>)</span><br><span class="line">plt.title(<span class="string">'Distribution of tokens length'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="NLPDemo_files/demo_22_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上述图像接近正态分布</span></span><br><span class="line"><span class="comment"># 根据 3 sigma 定理（正态分布规律），我们使用平均值 +- 2*标准差可以覆盖百分之95以上的case</span></span><br><span class="line"><span class="comment"># 取tokens平均值并加上两个tokens的标准差，</span></span><br><span class="line"><span class="comment"># 假设tokens长度的分布为正态分布，则max_tokens这个值可以涵盖95%左右的样本</span></span><br><span class="line">max_tokens = np.mean(num_tokens) + <span class="number">2</span> * np.std(num_tokens)</span><br><span class="line">max_tokens = int(max_tokens)</span><br><span class="line"></span><br><span class="line">print(max_tokens)</span><br></pre></td></tr></table></figure>
<pre><code>236
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算一下覆盖了多少case</span></span><br><span class="line"><span class="comment"># 取tokens的长度为236时，大约95%的样本被涵盖</span></span><br><span class="line"><span class="comment"># 我们对长度不足的进行padding，超长的进行修剪</span></span><br><span class="line">np.sum( num_tokens &lt; max_tokens ) / len(num_tokens)</span><br></pre></td></tr></table></figure>
<pre><code>0.9565
</code></pre><p>在这之后，我们会需要debug，但是呢，现在的sample都是index list形式的，所以不是很好直观地反映样本情况，我们需要构造一个函数来反过来通过index在cn_model中求vocab</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detokenize</span><span class="params">(tokens)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    translate tokens to text</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    text = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">            text = text + cn_model.index2word[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            text = text + <span class="string">' '</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text = detokenize(train_tokens[<span class="number">0</span>])</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<pre><code>的价格物超所值早餐不错服务也好很人性化呵呵 碰到卫生间马桶里撒花瓣的宾馆不过酒店的洗浴中心美容美发都在装修中不能使用预定时没有提到
</code></pre><p>由此可见，”单人间”这个词语丢失了, 标点符号也被舍弃了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始文本</span></span><br><span class="line">print(origin_train_txts[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<pre><code>单人间的价格物超所值.早餐不错.服务也好,很人性化.呵呵,第一次碰到卫生间马桶里撒花瓣的宾馆.不过酒店的洗浴中心,美容美发都在装修中不能使用.预定时没有提到.
</code></pre><p><strong>准备Embedding Matrix</strong><br>现在我们来为模型准备embedding matrix（词向量矩阵），根据keras的要求，我们需要准备一个维度为$(numwords, embeddingdim)$的矩阵，num words代表我们使用的词汇的数量，emdedding dimension在我们现在使用的预训练词向量模型中是300，每一个词汇都用一个长度为300的向量表示。<br>注意我们只选择使用前50k个使用频率最高的词，在这个预训练词向量模型中，一共有260万词汇量，如果全部使用在分类问题上会很浪费计算资源，因为我们的训练样本很小，一共只有4k，如果我们有100k，200k甚至更多的训练样本时，在分类问题上可以考虑减少使用的词汇量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(embedding_dim)</span><br><span class="line"></span><br><span class="line">num_words = <span class="number">50000</span></span><br><span class="line"><span class="comment"># 初始化embedding_matrix，之后在keras上进行应用</span></span><br><span class="line">embedding_matrix = np.zeros((num_words, embedding_dim))</span><br><span class="line"><span class="comment"># embedding_matrix为一个 [num_words，embedding_dim] 的矩阵</span></span><br><span class="line"><span class="comment"># 维度为 50000 * 300</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_words):</span><br><span class="line">    embedding_matrix[i,:] = cn_model[cn_model.index2word[i]]</span><br><span class="line"></span><br><span class="line">embedding_matrix = embedding_matrix.astype(<span class="string">'float32'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>300
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查index是否对应，</span></span><br><span class="line"><span class="comment"># 输出300意义为长度为300的embedding向量一一对应</span></span><br><span class="line">print(np.sum( cn_model[cn_model.index2word[<span class="number">333</span>]] == embedding_matrix[<span class="number">333</span>] ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># embedding_matrix的维度，</span></span><br><span class="line"><span class="comment"># 这个维度为keras的要求，后续会在模型中用到</span></span><br><span class="line">print(embedding_matrix.shape)</span><br></pre></td></tr></table></figure>
<pre><code>300
(50000, 300)
</code></pre><p>接下来,我们要完成上一步已经提到过步骤,那就是完成tokens(由索引构成的列表)长度的标准化<br>不够长的index list我们往这个list中填充无效索引0, 这里我们选择往列表前缀填充0, 当index list长度太长的时候,我们要对它进行一定的裁剪</p>
<p>由上面的实验结果我们可以知道, 236可以覆盖至少百分之95的sample, 所以我们要使用236作为标准化后的index list长度</p>
<p>这一步也就是所谓的 <strong>padding (填充) 和truncating (修剪) </strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行padding和truncating， 输入的train_tokens是一个list</span></span><br><span class="line"><span class="comment"># 返回的train_pad是一个numpy array</span></span><br><span class="line">train_pad = pad_sequences(train_tokens, maxlen=max_tokens, padding=<span class="string">'pre'</span>, truncating=<span class="string">'pre'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了提高训练效率,我们只选择词料库中的前50k个高频词作为训练集的参照</span></span><br><span class="line"><span class="comment"># 所以超出五万个词向量的词用0代替</span></span><br><span class="line">train_pad[ train_pad &gt;= num_words ] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们随便选择一个经过长度标准化的tokens(index list)看看是一个什么样的结果</span></span><br><span class="line">print(train_pad[<span class="number">100</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[    0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0     0
     0     0     0     0     0     0     0     0     0     0     0 11670
    40   640    35  1845  1487   348  2495    67    10   369    53   143
  1487     1 21604   169   710   865     1 14453  1487     5   784    11
   254   117    34   786  1883    30   369  1028]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备target向量，前2000样本为1，后2000为0</span></span><br><span class="line"><span class="comment"># 这一步的意思是给之前已经打包进来的tokens打一个标签</span></span><br><span class="line"><span class="comment"># 前2000个是positive评价, 后2000个是negative评价</span></span><br><span class="line"><span class="comment"># 将两个生成的一维list组合起来就可以了</span></span><br><span class="line">train_target = np.concatenate( (np.ones(<span class="number">2000</span>), np.zeros(<span class="number">2000</span>)) )</span><br><span class="line">print(len(train_target))</span><br><span class="line">print(train_target[<span class="number">1997</span>:<span class="number">2003</span>])</span><br></pre></td></tr></table></figure>
<pre><code>4000
[1. 1. 1. 0. 0. 0.]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分割这些原始的集合, 并且划分出训练集和测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 90%用来作为训练集, 10%用来作为测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(train_pad, train_target, test_size=<span class="number">0.1</span>, random_state=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们任意取一个sample来确认一下</span></span><br><span class="line"></span><br><span class="line">print(detokenize(X_train[<span class="number">29</span>]))</span><br><span class="line">print(<span class="string">"positive? : %d"</span> % y_train[<span class="number">29</span>])</span><br></pre></td></tr></table></figure>
<pre><code>                                                                                                                                                                                                                      一般情况吧这个价位的能有这样的硬件条件也算不错了适合情人约会不想 的
positive? : 1
</code></pre><p>现在我们用keras搭建LSTM模型，模型的第一层是Embedding层，只有当我们把tokens索引转换为词向量矩阵之后，才可以用神经网络对文本进行处理。<br>keras提供了Embedding接口，避免了繁琐的稀疏矩阵操作。<br>在Embedding层我们输入的矩阵为：$$(batchsize, maxtokens)$$<br>输出矩阵为： $$(batchsize, maxtokens, embeddingdim)$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始构造model</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(num_words)</span><br><span class="line">print(embedding_dim)</span><br><span class="line">print(max_tokens)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型第一层为embedding</span></span><br><span class="line">model.add(Embedding(num_words, embedding_dim, weights=[embedding_matrix], input_length=max_tokens, </span><br><span class="line">                    trainable=<span class="keyword">False</span>))</span><br></pre></td></tr></table></figure>
<pre><code>50000
300
236
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.add(Bidirectional(LSTM(units=<span class="number">32</span>, return_sequences=<span class="keyword">True</span>)))</span><br><span class="line">model.add(LSTM(units=<span class="number">16</span>, return_sequences=<span class="keyword">False</span>))</span><br></pre></td></tr></table></figure>
<p><strong>构建模型</strong><br>我在这个教程中尝试了几种神经网络结构，因为训练样本比较少，所以我们可以尽情尝试，训练过程等待时间并不长：<br><strong>GRU：</strong>如果使用GRU的话，测试样本可以达到87%的准确率，但我测试自己的文本内容时发现，GRU最后一层激活函数的输出都在0.5左右，说明模型的判断不是很明确，信心比较低，而且经过测试发现模型对于否定句的判断有时会失误，我们期望对于负面样本输出接近0，正面样本接近1而不是都徘徊于0.5之间。<br><strong>BiLSTM：</strong>测试了LSTM和BiLSTM，发现BiLSTM的表现最好，LSTM的表现略好于GRU，这可能是因为BiLSTM对于比较长的句子结构有更好的记忆，有兴趣的朋友可以深入研究一下。<br>Embedding之后第，一层我们用BiLSTM返回sequences，然后第二层16个单元的LSTM不返回sequences，只返回最终结果，最后是一个全链接层，用sigmoid激活函数输出结果。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"><span class="comment"># 我们使用adam以0.001的learning rate进行优化</span></span><br><span class="line">optimizer = Adam(lr=<span class="number">1e-3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              optimizer=optimizer,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们来看一下模型的结构，一共90k左右可训练的变量</span></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<pre><code>_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding_2 (Embedding)      (None, 236, 300)          15000000  
_________________________________________________________________
bidirectional (Bidirectional (None, 236, 64)           85248     
_________________________________________________________________
lstm_1 (LSTM)                (None, 16)                5184      
_________________________________________________________________
dense (Dense)                (None, 1)                 17        
=================================================================
Total params: 15,090,449
Trainable params: 90,449
Non-trainable params: 15,000,000
_________________________________________________________________
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个权重的存储点</span></span><br><span class="line">path_checkpoint = <span class="string">'sentiment_checkpoint.keras'</span></span><br><span class="line">checkpoint = ModelCheckpoint(filepath=path_checkpoint, monitor=<span class="string">'val_loss'</span>,</span><br><span class="line">                                      verbose=<span class="number">1</span>, save_weights_only=<span class="keyword">True</span>,</span><br><span class="line">                                      save_best_only=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试加载已训练模型</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    model.load_weights(path_checkpoint)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<pre><code>Unable to open file (unable to open file: name = &apos;sentiment_checkpoint.keras&apos;, errno = 2, error message = &apos;No such file or directory&apos;, flags = 0, o_flags = 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义early stoping如果3个epoch内validation loss没有改善则停止训练</span></span><br><span class="line">earlystopping = EarlyStopping(monitor=<span class="string">'val_loss'</span>, patience=<span class="number">3</span>, verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动降低learning rate</span></span><br><span class="line">lr_reduction = ReduceLROnPlateau(monitor=<span class="string">'val_loss'</span>,</span><br><span class="line">                                       factor=<span class="number">0.1</span>, min_lr=<span class="number">1e-5</span>, patience=<span class="number">0</span>,</span><br><span class="line">                                       verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义callback函数</span></span><br><span class="line">callbacks = [</span><br><span class="line">    earlystopping, </span><br><span class="line">    checkpoint,</span><br><span class="line">    lr_reduction</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line">model.fit(X_train, y_train,</span><br><span class="line">          validation_split=<span class="number">0.1</span>, </span><br><span class="line">          epochs=<span class="number">20</span>,</span><br><span class="line">          batch_size=<span class="number">128</span>,</span><br><span class="line">          callbacks=callbacks)</span><br></pre></td></tr></table></figure>
<pre><code>Train on 3240 samples, validate on 360 samples
WARNING:tensorflow:From /usr/lib/python3.7/site-packages/tensorflow/python/ops/math_ops.py:3066: to_int32 (from tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.cast instead.
Epoch 1/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.6279 - acc: 0.6637
Epoch 00001: val_loss improved from inf to 0.52382, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 32s 10ms/sample - loss: 0.6268 - acc: 0.6651 - val_loss: 0.5238 - val_acc: 0.7528
Epoch 2/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.4681 - acc: 0.7941
Epoch 00002: val_loss improved from 0.52382 to 0.49189, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 32s 10ms/sample - loss: 0.4685 - acc: 0.7938 - val_loss: 0.4919 - val_acc: 0.7972
Epoch 3/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.4387 - acc: 0.8031
Epoch 00003: val_loss improved from 0.49189 to 0.46409, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 29s 9ms/sample - loss: 0.4392 - acc: 0.8028 - val_loss: 0.4641 - val_acc: 0.7889
Epoch 4/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.3542 - acc: 0.8553
Epoch 00004: val_loss improved from 0.46409 to 0.40490, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 29s 9ms/sample - loss: 0.3524 - acc: 0.8562 - val_loss: 0.4049 - val_acc: 0.8250
Epoch 5/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.3913 - acc: 0.8253
Epoch 00005: val_loss improved from 0.40490 to 0.40423, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 29s 9ms/sample - loss: 0.3910 - acc: 0.8253 - val_loss: 0.4042 - val_acc: 0.8361
Epoch 6/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.3222 - acc: 0.8656
Epoch 00006: val_loss improved from 0.40423 to 0.39816, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 34s 11ms/sample - loss: 0.3246 - acc: 0.8642 - val_loss: 0.3982 - val_acc: 0.8278
Epoch 7/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.3409 - acc: 0.8600
Epoch 00007: val_loss improved from 0.39816 to 0.38914, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 29s 9ms/sample - loss: 0.3402 - acc: 0.8605 - val_loss: 0.3891 - val_acc: 0.8389
Epoch 8/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.2806 - acc: 0.8919
Epoch 00008: val_loss did not improve from 0.38914

Epoch 00008: ReduceLROnPlateau reducing learning rate to 0.00010000000474974513.
3240/3240 [==============================] - 28s 9ms/sample - loss: 0.2825 - acc: 0.8914 - val_loss: 0.3940 - val_acc: 0.8361
Epoch 9/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.2689 - acc: 0.8969
Epoch 00009: val_loss improved from 0.38914 to 0.36922, saving model to sentiment_checkpoint.keras
3240/3240 [==============================] - 28s 9ms/sample - loss: 0.2694 - acc: 0.8960 - val_loss: 0.3692 - val_acc: 0.8528
Epoch 10/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.2483 - acc: 0.9081
Epoch 00010: val_loss did not improve from 0.36922

Epoch 00010: ReduceLROnPlateau reducing learning rate to 1.0000000474974514e-05.
3240/3240 [==============================] - 29s 9ms/sample - loss: 0.2483 - acc: 0.9080 - val_loss: 0.3737 - val_acc: 0.8500
Epoch 11/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.2425 - acc: 0.9075
Epoch 00011: val_loss did not improve from 0.36922

Epoch 00011: ReduceLROnPlateau reducing learning rate to 1e-05.
3240/3240 [==============================] - 28s 9ms/sample - loss: 0.2419 - acc: 0.9080 - val_loss: 0.3747 - val_acc: 0.8472
Epoch 12/20
3200/3240 [============================&gt;.] - ETA: 0s - loss: 0.2415 - acc: 0.9087
Epoch 00012: val_loss did not improve from 0.36922
3240/3240 [==============================] - 29s 9ms/sample - loss: 0.2405 - acc: 0.9090 - val_loss: 0.3730 - val_acc: 0.8500
Epoch 00012: early stopping





&lt;tensorflow.python.keras.callbacks.History at 0x7f8ba949f5c0&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = model.evaluate(X_test, y_test)</span><br><span class="line">print(<span class="string">'Accuracy:&#123;0:.2%&#125;'</span>.format(result[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<pre><code>400/400 [==============================] - 2s 6ms/sample - loss: 0.3132 - acc: 0.8825
Accuracy:88.25%
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_sentiment</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text)</span><br><span class="line">    <span class="comment"># 去标点</span></span><br><span class="line">    text = re.sub(<span class="string">"[\s+\.\!\/_,$%^*(+\"\']+|[+——！，。？、~@#￥%……&amp;*（）]+"</span>, <span class="string">""</span>,text)</span><br><span class="line">    <span class="comment"># 分词</span></span><br><span class="line">    cut = jieba.cut(text)</span><br><span class="line">    cut_list = [ i <span class="keyword">for</span> i <span class="keyword">in</span> cut ]</span><br><span class="line">    <span class="comment"># tokenize</span></span><br><span class="line">    <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(cut_list):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cut_list[i] = cn_model.vocab[word].index</span><br><span class="line">            <span class="keyword">if</span> cut_list[i] &gt;= <span class="number">50000</span>:</span><br><span class="line">                cut_list[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            cut_list[i] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># padding</span></span><br><span class="line">    tokens_pad = pad_sequences([cut_list], maxlen=max_tokens,</span><br><span class="line">                           padding=<span class="string">'pre'</span>, truncating=<span class="string">'pre'</span>)</span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    result = model.predict(x=tokens_pad)</span><br><span class="line">    coef = result[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> coef &gt;= <span class="number">0.5</span>:</span><br><span class="line">        print(<span class="string">'是一例正面评价'</span>,<span class="string">'output=%.2f'</span>%coef)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'是一例负面评价'</span>,<span class="string">'output=%.2f'</span>%coef)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test_list = [</span><br><span class="line">    <span class="string">'酒店设施不是新的，服务态度很不好'</span>,</span><br><span class="line">    <span class="string">'酒店卫生条件非常不好'</span>,</span><br><span class="line">    <span class="string">'床铺非常舒适'</span>,</span><br><span class="line">    <span class="string">'房间很凉，不给开暖气'</span>,</span><br><span class="line">    <span class="string">'房间很凉爽，空调冷气很足'</span>,</span><br><span class="line">    <span class="string">'酒店环境不好，住宿体验很不好'</span>,</span><br><span class="line">    <span class="string">'房间隔音不到位'</span> ,</span><br><span class="line">    <span class="string">'晚上回来发现没有打扫卫生'</span>,</span><br><span class="line">    <span class="string">'因为过节所以要我临时加钱，比团购的价格贵'</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> test_list:</span><br><span class="line">    predict_sentiment(text)</span><br></pre></td></tr></table></figure>
<pre><code>酒店设施不是新的，服务态度很不好
是一例负面评价 output=0.07
酒店卫生条件非常不好
是一例负面评价 output=0.06
床铺非常舒适
是一例正面评价 output=0.55
房间很凉，不给开暖气
是一例负面评价 output=0.13
房间很凉爽，空调冷气很足
是一例负面评价 output=0.47
酒店环境不好，住宿体验很不好
是一例负面评价 output=0.04
房间隔音不到位
是一例负面评价 output=0.13
晚上回来发现没有打扫卫生
是一例负面评价 output=0.18
因为过节所以要我临时加钱，比团购的价格贵
是一例负面评价 output=0.09
</code></pre><p><strong>错误分类的文本</strong><br>经过查看，发现错误分类的文本的含义大多比较含糊，就算人类也不容易判断极性，如index为101的这个句子，好像没有一点满意的成分，但这例子评价在训练样本中被标记成为了正面评价，而我们的模型做出的负面评价的预测似乎是合理的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_actual = np.array(y_test)</span><br><span class="line"></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line">y_pred = y_pred.T[<span class="number">0</span>]</span><br><span class="line">y_pred = [<span class="number">1.0</span> <span class="keyword">if</span> p&gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> p <span class="keyword">in</span> y_pred]</span><br><span class="line">y_pred = np.array(y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出错误分类的索引</span></span><br><span class="line">misclassified = np.where( y_pred != y_actual )[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出所有错误分类的索引</span></span><br><span class="line">print(len(misclassified))</span><br><span class="line">print(len(X_test))</span><br></pre></td></tr></table></figure>
<pre><code>47
400
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们来找出错误分类的样本看看</span></span><br><span class="line">print(misclassified)</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> misclassified:</span><br><span class="line">    print(detokenize(X_test[idx]))</span><br><span class="line">    print(<span class="string">'预测的分类'</span>, y_pred[idx])</span><br><span class="line">    print(<span class="string">'实际的分类'</span>, y_actual[idx])</span><br></pre></td></tr></table></figure>
<pre><code>[  1   9  14  20  51  57  70  71  85  88  89  91  94 114 124 137 139 140
 146 170 171 198 199 206 210 229 231 236 242 250 262 270 280 292 323 325
 326 334 335 336 345 357 371 380 387 389 393]
                                                                                                                                                                                                                  只是 近出入 有蚊子  基本上夠一定的水平免费注册网站导航宾馆索引服务说明关于携程 英
预测的分类 0.0
实际的分类 1.0
车上的人仔细辨认结果还是 很多地方好不容易才开到酒店大门口那天正好下小雨门口保安只有 跑来我在酒店门口依然看不到车库入口要求保安带路于是他安排一个管理车库的工人 那工人带我们到车库后一听说我们是入住客人不能向他交停车费他立刻一溜烟不见人影害得我们找电梯 酒店找了半天这种情况也许以前很难体现出来也许平时也不觉得怎样过分但这几件事集中起来就反映了该酒店的管理薄弱的一方面最重要的是我觉得作为一个好评如潮的酒店更不应该了当然事后当晚值班经理的及时道歉和升级房间等等补偿行为也体现了该酒店管理层对客人的重视体现了酒店有错及时改进的诚恳态度而且 还通过携程要向我电话道歉我也确实感到该酒店能有如此态度很难能可贵了本来我不想点评此次事情但后来觉得也不妨通过我的客观褒贬让大家看到该酒店的真实品质也许我下次 考虑入住该酒店只是仍然希望酒店今后多积极发现不足免得以后入住该酒店的客人那么麻烦同时也影响自己的声誉
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                                                            感觉环境服务方面还不够位房间里面的洗浴设施有点发黄需要改善
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                                    服务基本上没有非常失望其酒店的服务和周围的优雅环境很 总而言之非常失望更不用谈性价比了
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                                          房间比较干净卫生间太小转身都费劲地理位置一半 胡同里不容易找到服务一般
预测的分类 0.0
实际的分类 1.0
店主的妹妹向我们介绍推荐景点行程安排之类的因我们不喜欢事前安排喜欢随性游玩在和黎阿姨聊了一会后并没有让其安排而是 在 游玩中了解到他们安排或者推荐游客都能有一定收益的 我们退房    到   因为行李较多所以特意问服务员是否可以在 上岸直接去桂林服务员也不清楚就跑去 阿姨回来后告知可以在 直接去桂林这样我们就背上所有行李  了然而实际上  是从 乘车去  开始乘机动  到 附近中间不下 直接返回 这样就是说我们要背着重重的行李来回跑而当初的本意是在如果回桂林还是必须返回 我们就找地方寄存行李不背着来回跑很是不厚道啊总体评价风景不错躺床上能看到 的 景观房但是不推荐住因为到晚上之后就没什么 可做只能去 城里其实在那里不管什么宾馆只要 肯定能看到山水回来还要找出租车或摩的；房间里边都没有宽带；最好自带洗漱用品；服务员还是很厚道很淳朴的
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                             除了房间门的隔音效果和 不强之外别的都还不错我又 将 卡片插在 了到北京才记起来赶紧打电话过去告诉我服务员收起来了 后再入住时找到了感谢
预测的分类 0.0
实际的分类 1.0
                                                                                                                                 房间 传说的 一个 还是真大除了这个好像没有其他的优点了早上赶火车到的想洗澡空调没有水还是有时无最奇怪的是淋浴竟然是要把那个小开关 按而不是拉这是我发现的 害我还无知的问前台打扫卫生 吸尘器竟然 早餐 早餐什么都没有20块太不值了电梯 顶楼21楼等个电梯要抽几支烟的不过服务员还是不错的不过诸多不快被美丽的景色和服务员的笑脸给抹杀了
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                   的  齐全包括洗浴间小毛巾吹风机等房屋装修新服务态度好如前台 好位于市中心但是 道而喧闹房间隔音效果不好早餐一般补充点评2007年9月4日：房屋价格适中但是 预定没有 该酒店前台价格与 一样
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                                                 酒店的房间很舒服但是打电话询问酒店位置的时候前台说不清楚;餐厅由于要接待团队就不能为 服务而且理直气壮
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                       房间非常小房间设施非常旧因为装修至今已经10年了房间空气非常 打开门 非常大的烟味和 迎面扑来服务还不错虽然帮我从6 到了9楼但是房间空气依然非常差非常差非常差得不能接受
预测的分类 1.0
实际的分类 0.0
                                                                                                                                         我已经入住很多次了我之所以选择它是因为地理位置好但是 比较差而且餐饮价格也不合理并且现在装修噪音很大下次我是不会选择了宾馆反馈2008年1月7日：尊敬的宾客：由于酒店近期装修改造给您带来了 对此我们 根据客人反馈信息 对房价进行了调整还为入住 的客人赠送欢迎水果房内免费宽带上网等增值服务我们将秉承“宾客至上服务第一”的宗旨  
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                    房间 卫生间是很多 房间比较大大床不错我喜欢价格还可以就是 了不舒服服务员水平差不多 前老国营的水平下次 一家住不过据说小姐不错俺没试
预测的分类 1.0
实际的分类 0.0
宽敞干净整洁隔音不错服务很温馨： 小 还有清凉的 和水果点点细节体现着一个 酒店的 再说点小插曲在前台服务生查看了预订情况推荐我升级我谢绝了他们的提议之后说 的是 我说我要大 貌似预订时是无法选择大床还是 的接着便打电话询问有没有豪华大床间听着他们一会儿说有一会儿说没有弄得我一头雾水最后告诉我：现在没有房间因为 酒店的缘故所以给我免费升级这个小插曲虽然让人有点不快但终究本着顾客是上帝的原则去解决问题比较满意以后 选择这里宾馆反馈2008年8月13日：感谢您选择 大酒店入住并对酒店予以认可看您的评论猜想您可能是通过网络直接预订的房间吧通过网络直接 没有对房间 的选项例如大床等 )如果 对房间有  拨打电话预订酒店和携程的预订人员会共同做好记录按您的要求提前准备房间携程 电话：800-820- -820- 手机；酒店 电话： - 再次对您的点评表示感谢祝 一切顺利
预测的分类 0.0
实际的分类 1.0
      这家酒店虽然设施比较老价格比较贵很小的经济 还330但是早餐很不错服务更是不错服务生很 见主动过来帮忙拿东西临走我想把车里的垃圾找垃圾箱扔了正找呢服务生又主动过来问情况然后帮我把垃圾拿走扔掉了过了一个小时酒店打来电话问是不是衣服落他们那儿了可是我们上了高速回不去了于是留了地址请他们寄回来结果 一早衣服就到了所以感觉服务很好还特意打电话回去感谢他们这服务啊跟那个啥交通大厦对比一下啊那个天上地下啊停车没人管然后前台 没收到携程的订单还不跟携程联系非让我自己联系手机给她后她倒聊上了于是我生气出门走人结果就 的停车保安竟然  5块的停车费这个价格高一点房间小一点我也认了强烈建议携程把交通大厦从合作对象中剔除实在有损携程形象我想点评交通大厦来着因为很气愤就没有住所以不让我点评不过我给携程写了意见了也建议大家不要订交通大厦即使携程推荐
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                                                       也就占了个位置还可以到光内部设施和消耗品配备实在是不怎么样而且很贵
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                                     最大的优势是距火车站 坐公交去  等景点十分方便宾馆设施太陈旧电视效果差
预测的分类 1.0
实际的分类 0.0
                                                          酒店硬件和位置都好但服务令人生气12 地震这 我通过携程入住了这酒店 因为办事延误了没有来得及退房下午携程问是否要退?但因已经过了 我们要求 结果被告知 房房价涨40元和50元了说是星期一是特价 取消特价了我说我们连同住了 应该是同一 酒店后来说如果当时通过携程预订住 也是 价的如果退房的话 半天的费还说三星以上宾馆 10服务费总之感觉象是被宰了今后是不会再入住这宾馆了补充点评2008年5月14日：补；由于天下雨我们要向酒店 并出示住房证告知我们是酒店客人谁知被告知先登记再每人押100元缺乏人性化同样的事发生在凤凰 酒店只要出示 登记就可以了
预测的分类 0.0
实际的分类 1.0
人十分失望的 反馈2008年6月20日：感谢您选择入住上海绿地 全套房酒店并给予我们 的建议首先请允许我们为您简单介绍一下我们的酒店概况我们属于一家 连锁酒店集团提供高优质标准的 服务迎合不同种类客户的需求希望给为您及其他客人带来回家的感觉我们的客房最小面积为65平方米最大至100平方米不等 套房均配备简洁齐全的现代化 酒店提供餐饮 酒吧健身等一系列设施此次您所入住的行政套房其面积为75平方米每晚 元的房价 客房其设计风格和建筑布局比例以客厅为主在同区域五星级酒店中具有较高的性价比如客户想追求更加豪华舒适的套房也可选择我们的贵宾套房其 为85平方米其次我们酒店与携程 是合作伙伴关系我们总是以最优惠的价格最好的 提供给携程的客户们以保持长期友好的合作关系相信携程 也秉承同样的宗旨 地将每一家签约酒店推荐给忠实的客户最后再次感谢您的忠实建议希望下次能有机会为您提供更优质的服务谢谢
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                             一切还行就是对通过网络预订的房间为什么就不能灵活一点半天房都是合情合理的啊尤其是换住连锁酒店更应该 
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                    该酒店的确是靠近 --湖畔哦；但酒店的内部环境的确无法 哦走廊气味令人反感房间 不干净卫生间气味令人作呕 空调漏水“”只是前台接待小姐态度非常 客房服务的大嫂就太差了希望携程相关领导有空 一下建议有准备去 南山 的游客要么住 宾馆要么入住南山  景区内哦空气极佳挂三星有当地 的标准哦
预测的分类 1.0
实际的分类 0.0
          7月25 家人到泰山玩通过携程订的华侨大厦的房间说是搞活动花280升级到360的房间但是实际我们也不知道280和360的房间到底是怎样的对华侨大厦的评价和以前很很多网友的评价一样：服务很热情但是设施太陈旧在 上看酒店的反馈说是有 的房间但是 的时候携程的工作人员不知道我们订的房间是否是 的 希望携程以后把工作做仔细一些入住华侨大厦从 前台带房间服务人都态度很好很热情对客人的要求反应很快我因为带了孩子要求  洗漱用品到房间刚放下电话没多久服务员就送来了对一些我们询问的怎么去泰山玩附近有什么好吃的等问题都很耐心的回答房间有欢迎 而且分量不小很实在呵呵但是华侨大厦的设施确实太陈旧了很多地方的墙纸已经脱落房间的浴室比较小而且没有独立的 感觉老人和小孩使用时比较不方便但是良好的服务还是可以弥补这些不足的而且价钱也不贵感觉还可以接受
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                      我5月30日入住6月1日退房但比较离谱的是当我5月31日外出办事时回来竟发现房间已经 当时我极其郁闷酒店也很纳闷幸好房间我没有放任何 还好酒店的应急方案不错并送了 水果致歉最好告诉我说是 员工 这个理由有点勉强
预测的分类 0.0
实际的分类 1.0
                                                                                                                                             该酒店位置  3分钟路程房间宽敞早餐可以甜点很好吃但大堂太小电梯少客人 和写字楼混用很不方便从房间装修看的确是个 但携程上却说是 标准实际上很难达到 水平该酒店最大问题是没有给客人准备免费袋装茶茶杯旁边有一小桶茶叶很容易误认为是免费的谁知结账 了我11块钱服务员的解释是如果要免费袋装茶宾馆可以 提供牵强的很
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                                            房间还比较干净交通方便离外滩 但外面声音太大休息不好
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                              房间大细节不好住过上海  三亚 这个 最差把我 的携程积分都弄丢了呵呵携程 我好 很烦最后还是没用补充点评2008年4月10日：是的空调也不好调节弄了几遍都不合适早餐那个简单简单得过分了
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                                                        价格实惠基本还可以宾馆反馈2008年4月17日：希望下次再入住本酒店
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                                              月之后再次入住一进门大厅里 女工作人员就叫得出我的名字很不一般服务没得说酒店位置也很好位于 中心
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                        房间价格  2元 所有价格还要 服务费房间设施一般   部 免费的机场巴士好像是对客人的赏赐坐了后觉得很不舒服这家酒店我以后是绝对不会去了其他 也都免了
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                          这家酒店位置房间性价比都不错的但不知是不是由于客人多服务自然下降携程的客人好象在这里 受欢迎每次入住要不是订的大 没有要不是房间没有要不是还没有打扫出来而且不能积会员卡的分前台说是上面规定的也没有什么依据补充点评2007年12月9日：这家酒店的服务越来越差 也旧了大不如从前以后不住了
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                            这次入住感到服务人员的工作态度不如以前整体工作热情也不象其他 那么专业因为 的房间满了于是给我升级到行政套房这个本来是不错的安排但是不知道为什么偏偏这个房间里早晚都有 股噪音；而我朋友住在我下面  就被行政 准备早餐的声音吵醒酒店2楼西餐厅服务还是很好的
预测的分类 0.0
实际的分类 1.0
点评2008年8月3日：只能说服务人员的热情是可以打高分的但 很一般房间的设施实在太差房间里居然没有小冰箱提供的不是 是大的 不是很 我是看了诸位的评价后才下定决心订这酒店的但太失望了很怀疑这些高分是怎么 的宾馆反馈2008年8月13日：尊敬的先生：请允许我们这样称呼您因您入住时的姓名与宾客 姓名不一致非常感谢您的留言及对酒店提出的 对于您所指出的关于本酒店的各类硬件问题酒店方已有计划将于年底对客房及相关设施进行装修；同时对于酒店服务方面等出现的问题已引起酒店高层的高度关注酒店 对于此事进行彻底调查并对相关员工做出相应处理同时酒店 对员工进行各方面的培训加强服务意识提高服务品质；希望下次有机会为您提供更优质的服务我们已把您的信息存入 资料下次入住时我们会提供个性化服务最后再次感谢您对本酒店提出的各种建议以便于我们更好的为客人服务提高总体服务品质
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                                                 酒店不好找里面的环境还可以打车不方便
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                    网上介绍的比较好但是实际却是 现象交通非常不便晚上除非包车否则根本没法出行；另外酒店性质为居家酒店服务态度服务质量比较一般周围环境也没有传说中的那么诗意化如果想体验农村生活的话可以 否则可以考虑 街上一带的住宿
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                                                  设施一般大堂服务没有笑容其它方面还可以
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                                            酒店比较偏了虽然是在东方路上周围也没什么餐馆可以吃饭的
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                建议旅游的人住 这个酒店太远了交通不方便客房 但浴室 有异味白天水温 自己去的价格比携程的价格要便宜约150到180就能拿下不过服务态度停不错的
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                               海景花园是我所有住过的５星酒店中服务最好的一家另外他们的 餐厅非常地道并且 如果去青岛  它 补充点评2008年7月29日： ; ; ; ; ; ; ; ; ; ;
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                                              房间不算太小床不错虽然不 但也挺舒服干净最大的问题是上网太贵 抢钱似的为什么香港的酒店都没有免费上网呢
预测的分类 0.0
实际的分类 1.0
                                                                   订了 高级房只有这种 才有 订的时候忘记注明要 的但是要了 早餐后来我的客人到了酒店前台说： 了 大床房我不知道携程是怎么跟 沟通的那天下着大雨客人也不能转其他酒店害我丢尽颜面后来携程的一个工作人员打电话过来除了顶嘴什么事情也不能帮我解决我认为： 了 早餐虽然我忘记了说一定要 的可是携程也应该帮我确认一下估计那天酒店生意好就随便把我的房间 大床房后来携程那个工作人员还说：你有可能带朋友来吃早餐才订 早餐的这很正常我觉得这个服务态度也真是够差的我一直在用 现在已经是白金了但是这样的服务态度我真的觉得很遗憾
预测的分类 0.0
实际的分类 1.0
                                                        酒店地理位置较偏如无 不建议入住酒店在装修 方面并不能体现 的标准其实底子还是很不错的却弄得有些蛮荒的感觉如酒店 前后的草坪都未能很好的利用酒店的服务员很滑稽会用眼光注视客人但却不会问好那么还不如不注视入住时前台 男生还在用扬州话聊电话对客人 房间的装修很单调墙面上都是素色的墙纸大面积的 却无 装饰画单调无比特别是 的21寸电视实在 有些搞笑卫浴设施到都是 的勉强过关至于学 酒店的通透卫浴设计相对 酒店有些不伦不类吧酒店的自助早餐 没有变换菜式被好友不幸 呵呵如果你不是 苛刻的人还是能接受这样的酒店的只是离 实在有些距离哦还有酒店大厅进出的 反应极端的迟钝哈哈
预测的分类 0.0
实际的分类 1.0
                                                                                                                                                                                                             位置比较好卫生条件也还行就是房间太小高级大床房的大床还不如一般酒店的 的床而且床实在是睡的不是很舒服
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                               酒店位置比较偏远按照地址打车去被送到另外一个相同地址的地方希望酒店引起注意房间格调很前卫也许年轻人还可以接受
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                          该酒店确实性价比不是很高距离该酒店500 的衡阳 应该会比这家好很多我也 价格了 208前台 年198携程价
预测的分类 1.0
实际的分类 0.0
                                                                                                                                                                                                            绝对不是五星：晚8 去的2楼 没什么人用餐餐厅环境犹如一般小店餐具也很一般桌上没有餐巾纸没有牙签上菜也慢
预测的分类 0.0
实际的分类 1.0
            由于在南京住的银河 感觉不错所以这次来成都退了 到万达 接机的师傅和行李员都非常的不错但接下来发生的事情让我觉得非常气愤问前台要了 房卡 是开不了门的然后去大堂换了张并出去吃东西可回来发现在前台 房卡还是开不了门在走廊里等了 才由行李员拿了 的房卡进房间发现 没有开然后打电话给房屋中心 也床最 的是我的房间 听见电梯机器的声音吵得睡不着最后打电话给大副换房间半夜 拿着大 在换房间 由此以来 发生在五星级酒店的事情宾馆反馈2008年3月25日：酒店回复：非常感谢您的光临和对我们 品牌的关注我们对您在饭店遇到的不快 也向您对我们饭店服务和设施中提出的不足致以诚挚的感谢我们将加强前台员工的培训和监督使服务质量提升把品牌做得更好并衷心的希望您有机会再来饭店体验我们各方面的提高
预测的分类 1.0
实际的分类 0.0
                                                                             首先是让我满意的酒店接机服务这一点是和大家取得共识的了我是来 办事的去 办事在这里住还是非常方便的没有车服务员会 的帮我 让我比较感动的是 要去办事 却发现衣服挂了口子因为急着出去没时间处理而且本人 手艺也比较差于是 之中找到了服务员回来的时候衣服 了皮鞋也擦亮了一定没耽误事在这里对她们的服务表示小小的感谢补充点评2007年12月20日：看了大家点评小补充 ：鄙视一下 的那位朋友交教育基金才6块前还要报销没的报销还抱怨住高级酒店的人啊这是 话大家不要 实在看不过去了本人支持 
预测的分类 0.0
实际的分类 1.0
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/01-pack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/27/01-pack/" class="post-title-link" itemprop="url">01-pack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-27 15:52:32" itemprop="dateCreated datePublished" datetime="2019-01-27T15:52:32+08:00">2019-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h1><p>0-1背包问题是经典的动态规划问题，它有两种衍生的问题形式，我们称之为完全背包问题和多重背包问题</p>
<h2 id="基本的0-1背包问题："><a href="#基本的0-1背包问题：" class="headerlink" title="基本的0-1背包问题："></a>基本的0-1背包问题：</h2><h3 id="热动分析-jpg"><a href="#热动分析-jpg" class="headerlink" title="热动分析.jpg"></a>热动分析.jpg</h3><blockquote>
<p>给一个capacity为n的背包，能装weight总共不超过n的物品，给定m个物品，每一个物品具有价值value和重量weight,我们希望能装的物品value的总和越大越好，那么应该怎么做呢？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ciso646&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = SOME_VAL();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_M = SOME_VAL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> weight[MAX_M];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value[MAX_M];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dp_cache[MAX_M][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_M; ++i)</span><br><span class="line">        <span class="built_in">memset</span>(dp_cache[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*MAX_N);</span><br><span class="line">    <span class="built_in">memset</span>(weight, <span class="number">0</span>, <span class="keyword">sizeof</span>(weight));</span><br><span class="line">    <span class="built_in">memset</span>(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取输入</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_input</span><span class="params">(<span class="built_in">std</span>::istream&amp; is = <span class="built_in">std</span>::<span class="built_in">cin</span>, <span class="built_in">std</span>::ostream&amp; os = <span class="built_in">std</span>::<span class="built_in">cout</span>)</span> </span>&#123;</span><br><span class="line">    is &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m <span class="keyword">and</span> i &lt;= MAX_M; ++i) &#123;</span><br><span class="line">        is &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法执行</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m <span class="keyword">and</span> i &lt;= MAX_M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n <span class="keyword">and</span> j &lt;= MAX_N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(weight[i] &lt;= j)</span><br><span class="line">                dp_cache[i][j] = <span class="built_in">std</span>::max(dp_cache[i - <span class="number">1</span>][j], dp_cache[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_cache[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    get_input();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; proc() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这个代码基本就是解决基本0-1背包问题的算法思路了，我们可以看到，问题解决的关键在于找到一条合理的状态转移方程，所以我们考虑用一个合适的“容器”，用来记录一些中间状态，比如dp_cache[i][j]用来表示：</p>
<blockquote>
<p>考虑前i个物品（1,…,i）中，在容量为j的情况下能够装下的物品的最大价值。为了减少思维负担，我们信任这个最大价值，并且认为他是最优的，那么下一步的问题就是我们要不要在继续装下一个物品</p>
</blockquote>
<p>那么问题就转化成dp_cache[i + 1][j]究竟是容量不够没有装下第 i+1 个物品，还是装下了却得不偿失所以不装，还是装下了确实地能够提高整体容纳物品的价值总和，所以我们会有下面的思考</p>
<blockquote>
<p>dp_cache[i + 1][j] = k</p>
</blockquote>
<ul>
<li><p>当不能装下这个物品（第i + 1个物品），也就是j比第i + 1个物品的的重量要小，那么自然而然不装下第i + 1个物品，k就是dp_cache[i][j]</p>
</li>
<li><p>当能够装下这个物品，那么我们需要考虑要不要装下它，是否值得</p>
<ul>
<li>如果值得，那么k就是dp_cache[i][j - weight[i + 1]] + value[i + 1]，也就是考虑前i个物品，在容量为j - weight[i+1]扣除第i+1个物品的剩余容量的最佳值加上装入的新物品的价值之和</li>
<li>否则，保持不变，也就是k = dp_cache[i][j]比装入这个物品后的情况(dp_cache[i][j - weight[i + 1]] + value[i + 1])要大，那么我们不装入这个新的物品</li>
</ul>
</li>
</ul>
<p>为了方便下面我们使用dp数组代指dp_cache</p>
<p><strong>这里注意一下</strong> </p>
<p>值得注意的是，我们在迭代的过程中，要求dp[i][j]需要考虑的“原材料”，也就是我们所说的迭代前项，是dp[i-1][0,1,2,…,j]与本行的数据都没有关系（指dp[i][0,1,2,3,…,j - 1]），仅仅只用到了上一行的数据，也就是说，将暂存数组从二维优化为一维是可能的</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xx1</td>
<td style="text-align:left">xx2</td>
<td style="text-align:left">xx3</td>
</tr>
<tr>
<td style="text-align:left">oo1</td>
<td style="text-align:left">oo2</td>
<td style="text-align:left">tag</td>
</tr>
</tbody>
</table>
<p>如上表所示，要求tag，那么xx是需要用到的，oo是用不到的，而要求第二行第二列的值，也只需要第一行第一列，第一行第二列的值作为推导的前项。</p>
<p>假如我们只用一个一维数组dp_cache来暂存价值信息，并且我们还只有第一行的数据</p>
<p>他现在长这样</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xx1</td>
<td style="text-align:left">xx2</td>
<td style="text-align:left">xx3</td>
</tr>
</tbody>
</table>
<p>现在，我们要求下一行第一个数据oo1，没问题，直接使用这个一维数组的第一个数据递推</p>
<p>他现在长这样</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">oo1</td>
<td style="text-align:left">xx2</td>
<td style="text-align:left">xx3</td>
</tr>
</tbody>
</table>
<p>接下来，我们要求下一个数据oo2，但是问题出现了，求oo2需要xx1还有xx2，但是xx1已经被覆盖了，这样的话我们这个想法就宣告失败了。</p>
<p>那么，如果我们倒着来求dp[i+1][0…j]呢？</p>
<p>我们先求oo3(也就是之前的tag)，oo3需要xx1, xx2, xx3来递推得到，也确实有，所以我们顺利得到oo3</p>
<p>这样，这个表现在长这样</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xx1</td>
<td style="text-align:left">xx2</td>
<td style="text-align:left">oo3</td>
</tr>
</tbody>
</table>
<p>我们再求oo2，需要xx2和xx1，可以得到</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xx1</td>
<td style="text-align:left">oo2</td>
<td style="text-align:left">oo3</td>
</tr>
</tbody>
</table>
<p>最后我们需要求oo1,可以由xx1推导得到</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">oo1</td>
<td style="text-align:left">oo2</td>
<td style="text-align:left">oo3</td>
</tr>
</tbody>
</table>
<p>这样，我们前i + 1个物品的dp数组已经求出来了</p>
<p>所以相对应的，我们可以把我们的算法代码优化一下,注意由于dp_cache结构改变init()函数也应当改变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp_cache[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp_cache));</span><br><span class="line">    <span class="built_in">memset</span>(weight, <span class="number">0</span>, <span class="keyword">sizeof</span>(weight));</span><br><span class="line">    <span class="built_in">memset</span>(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，第二个版本的算法执行函数就出来了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dp_cache[MAX_M][MAX_N]改为dp_cache[MAX_N]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dp_cache[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m <span class="keyword">and</span> i &lt;= MAX_M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt;= MAX_N; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= weight[i])</span><br><span class="line">                dp_cache[j] = <span class="built_in">std</span>::max(dp_cache[j - weight[i]] + value[i], dp_cache[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_cache[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果j小于weight[i]那么，显然是没有继续往下遍历的必要了，所以可以继续改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终版本</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dp_cache[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m <span class="keyword">and</span> i &lt;= MAX_M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= weight[i] <span class="keyword">and</span> j &lt;= MAX_N; --j)</span><br><span class="line">            dp_cache[j] = <span class="built_in">std</span>::max(dp_cache[j - weight[i]] + value[i], dp_cache[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_cache[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上，就是0-1背包问题的解法了，假设物品有m个，背包容量为n,他的空间复杂度是O(n)，时间复杂度是O(n*m);</p>
<p>时间上应该是可以再优化的（比如说最后一次迭代不去求dp[m][0….j-1]，直接返回dp[m][n]也就是dp_cache[n]），但是O(n*m)的时间复杂度还是逃不掉的</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="魔法分析-jpg"><a href="#魔法分析-jpg" class="headerlink" title="魔法分析.jpg"></a>魔法分析.jpg</h3><blockquote>
<p>给一个capacity为n的背包，能装weight总共不超过n的物品，给定m种物品，每一种物品具有价值value和重量weight,我们希望能装的物品value的总和越大越好，那么应该怎么做呢？</p>
</blockquote>
<p><strong>注意这个问题和基本0-1背包问题的区别！！！</strong></p>
<p><strong>注意这个问题和基本0-1背包问题的区别！！！</strong></p>
<p><strong>注意这个问题和基本0-1背包问题的区别！！！</strong></p>
<p><strong>m种物品的数量是不限的！</strong></p>
<p><strong>m种物品的数量是不限的！</strong></p>
<p><strong>m种物品的数量是不限的！</strong></p>
<p>有的小伙伴这个时候就有点懵逼了，那咋办啊，暴力遍历一下啊？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们假设初始化函数没有问题</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dp_cache[MAX_M][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp_max;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_M <span class="keyword">and</span> i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= MAX_N <span class="keyword">and</span> j &lt;= n; ++j) &#123;</span><br><span class="line">            tmp_max = dp_cache[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k*weight[i] &lt;= j; ++k) &#123;</span><br><span class="line">                tmp_max = <span class="built_in">std</span>::max(tmp_max, dp_cache[i - <span class="number">1</span>][j - k*weight[i]] + k*value[i])</span><br><span class="line">            &#125;</span><br><span class="line">            dp_cache[i][j] = tmp_max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_cache[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法简单粗暴够直接，我喜欢，但是它没有利用到同一行的数据</p>
<p>我们记</p>
<blockquote>
<p>k1 = dp[i][j] + value[i]</p>
</blockquote>
<blockquote>
<p>k2 = dp[i - 1][j + weight[i]]</p>
</blockquote>
<p>dp[i][j]代表的是前 i <strong>种</strong>物品在 j 这个容量下的最优值，我们足够地信任他,那么当我们考虑dp[i][j + weight[i]]的值的时候，我们要作出一个判断，是继续装第 i 种物品更加合适还是只考虑前 i - 1 种但是容量增大更合适</p>
<p>也就是说</p>
<blockquote>
<p>记 x = j + weight[i]</p>
</blockquote>
<blockquote>
<p>dp[i][x] = max(dp[i][x - weight[j]] + value[i], dp[i - 1][x])</p>
</blockquote>
<blockquote>
<p>dp[i][x] = max(k1, k2)</p>
</blockquote>
<p>这样的话，我们就可以得到相对不那么暴力的算法了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="comment">// 我们假设初始化函数没有问题</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dp_cache[MAX_M][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_M <span class="keyword">and</span> i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= MAX_N <span class="keyword">and</span> j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; weight[i])</span><br><span class="line">                dp_cache[i][j] = dp_cache[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp_cache[i][j] = <span class="built_in">std</span>::max(dp_cache[i][j - weight[i]] + value[i], dp_cache[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发现了没有，dp[i][j]的递推的“原材料”是dp[i][j-w]还有dp[i-1][j]</strong></p>
<p>我们是否可以效仿之前提到的做法，优化这个算法的空间复杂度，将二维暂存数组转化为一维数组以节省空间呢</p>
<p>当然可以！！</p>
<p>由于之前详细讲过转化成滚动数组的验证方法，这里只是给出较为简略的说明</p>
<p>这是二维数组版本</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xx1</td>
<td style="text-align:left">xx2</td>
<td style="text-align:left">xx3</td>
</tr>
<tr>
<td style="text-align:left">oo1</td>
<td style="text-align:left">oo2</td>
<td style="text-align:left">oo1</td>
</tr>
</tbody>
</table>
<p>好的，现在假设我们已经得到了前 i - 1 种的结果 xx1 xx2 xx3</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xx1</td>
<td style="text-align:left">xx2</td>
<td style="text-align:left">xx3</td>
</tr>
</tbody>
</table>
<p>现在我们要求 oo1, oo1需要xx1还有边界的0（希望这个无需说明）作为递推的前项</p>
<p>现在这个表长这样</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">oo1</td>
<td style="text-align:left">xx2</td>
<td style="text-align:left">xx3</td>
</tr>
</tbody>
</table>
<p>现在我们要求 oo2，oo2要求同一行的前置位已经求出和同一列的前置位已经求出，也就是ooX(X &lt; 2)还有xx2的数据作为递推的前项，这里刚好满足，所以我们填下oo2</p>
<p>现在这个表长这样</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">oo1</td>
<td style="text-align:left">oo2</td>
<td style="text-align:left">xx3</td>
</tr>
</tbody>
</table>
<p>现在我们要求 oo3，oo3要求同一行的前置位已经求出和同一列的前置位已经求出，也就是ooX(X &lt; 3)还有xx3的数据作为递推的前项，这里刚好满足，所以我们填下oo3</p>
<p>现在这个表长这样</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">oo1</td>
<td style="text-align:left">oo2</td>
<td style="text-align:left">oo3</td>
</tr>
</tbody>
</table>
<p>大功告成</p>
<p>我们反过来思考一下，为什么基本的0-1背包问题的递推要避开同一行的数据而不得不倒着遍历？</p>
<p><strong>恰恰是因为要避免重复装入第i个物品</strong></p>
<p>而在完全背包问题中，我们要反其道行之,就是要考虑可能的重复装入情况，这样最终的代码反而是非常简洁的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终版，初始化函数什么的自己去改，这里只展示proc函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dp_cache[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m <span class="keyword">and</span> i &lt;= MAX_M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n <span class="keyword">and</span> j &lt;= MAX_N; ++j)</span><br><span class="line">            dp_cache[j] = <span class="built_in">std</span>::max(dp_cache[j - weight[i]] + value[i], dp_cache[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_cache[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码仅供参考</p>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><h3 id="不想分析-jpg"><a href="#不想分析-jpg" class="headerlink" title="不想分析.jpg"></a>不想分析.jpg</h3><p>你直接把它转换成基本0-1背包问题不就完事了么，这题摸了</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>最后祝您，身体健康，再见</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/regex-learning0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/regex-learning0/" class="post-title-link" itemprop="url">regex_learning0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 20:01:42" itemprop="dateCreated datePublished" datetime="2019-01-18T20:01:42+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="这篇博客就来写一点有关正则表达式的笔记"><a href="#这篇博客就来写一点有关正则表达式的笔记" class="headerlink" title="这篇博客就来写一点有关正则表达式的笔记"></a>这篇博客就来写一点有关正则表达式的笔记</h1><h2 id="为什么突然要写这个"><a href="#为什么突然要写这个" class="headerlink" title="为什么突然要写这个"></a>为什么突然要写这个</h2><p>关于我个人的近况，我最近找到了一家实习公司做分布式爬虫，由于个人不是很熟悉正则表达式相关的东西，在review老代码的时候遇到了一些问题，其中看不懂正则表达式占了很大的一部分</p>
<h2 id="话不多说，进入正题"><a href="#话不多说，进入正题" class="headerlink" title="话不多说，进入正题"></a>话不多说，进入正题</h2><h4 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h4><p>正则表达式就是用一些特殊的字符组成的特殊的字符串，这个字符串用一些定义过的特殊字符来代表一些模式，我们可以认为他是一种模式串（pattern），他对于于一个字符串集合，这个集合内的的所有字符串有一个公共的可以用模式串匹配的特征，我们称这些字符串是对应于这个模式串（也就是正则表达式）是匹配的</p>
<h4 id="一个正则表达式可以由哪些字符组成？他们的含义是什么"><a href="#一个正则表达式可以由哪些字符组成？他们的含义是什么" class="headerlink" title="一个正则表达式可以由哪些字符组成？他们的含义是什么"></a>一个正则表达式可以由哪些字符组成？他们的含义是什么</h4><h6 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h6><p>普通字符就是最简单的字符，这些字符通常是可以“打印的”，</p>
<h6 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h6><p>由于很多字符是不可以打印的，所以我们思考去用上这些字符来作为我们的模式匹配的规则组成部分，由于他们大部分是不可见的，为了表示他们我们很多情况下需要使用转移字符 ‘\’</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\cx</td>
<td style="text-align:left">匹配所有与’x’相匹配的ctrl+’x’,\cc代表一个ctrl+c所对应的字符（这个字符是不可打印的），\cM代表一个ctrl+M字符，这个x必须是字母</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">匹配一个换页符号，这个通常很难用上</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">匹配一个换行符号</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">匹配一个回车符号</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">匹配任何一个任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td style="text-align:left">\S</td>
<td style="text-align:left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">制表符，等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td style="text-align:left">\w</td>
<td style="text-align:left">垂直制表符号，等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
<h6 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h6><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配输入字符串的结尾位置，如果设置了RegExp对象的Multiline属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td>
</tr>
<tr>
<td style="text-align:left">()</td>
<td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">可以匹配<strong>0个字符或者多个字符</strong>，如果要使用<em>这个字符本身请使用\</em></td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">可以匹配<strong>1个字符或者多个字符</strong>，如果要使用+这个字符本身请使用+</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配除了换行符\n之外的所有<strong>单个</strong>字符</td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td>
</tr>
<tr>
<td style="text-align:left">{</td>
<td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td>指明两项之间的一个选择。要匹配</td>
<td>，请使用 \</td>
<td>。</td>
</tr>
</tbody>
</table>
<h6 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h6><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td style="text-align:left">{n}</td>
<td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td style="text-align:left">{n.}</td>
<td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td style="text-align:left">{n.m}</td>
<td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
<h6 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h6><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td style="text-align:left">\B</td>
<td style="text-align:left">非单词边界匹配。</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/tiny_socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/25/tiny_socket/" class="post-title-link" itemprop="url">用C++实现一个非常简单的socket即时通信机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-25 09:10:20" itemprop="dateCreated datePublished" datetime="2018-12-25T09:10:20+08:00">2018-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在这个简单的demo中，我们需要两个主要的部分</p>
<ol>
<li>服务器：能够接受新的客户端连接，并将每个客户端发过来的消息发给所有其他的客户端</li>
<li>客户端：能够连接服务器，并且向服务器发送信息</li>
</ol>
<p>这个是最简单的群聊功能, 以后有空的话考虑加入两个客户端之间的私聊功能, 第一版我不会加入太多的东西,包括但不限于线程池, 多线程编程, 超时重传, 确认收包( 当然还包括GUI )等特性在初版中我都不会涉及, 这一次的理解重点在于Linux epoll和C/S架构的理解</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>从之前的需求的大致整理,我们可以归纳出以下几条要点</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>连接服务器</li>
<li>支持用户输入信息,发送信息给服务器</li>
<li>接受并且显示服务器的信息</li>
<li>退出连接</li>
</ol>
<p>针对上述需求, 客户端实现需要两个进程, 分别支持下面的功能</p>
<p>对于子进程:</p>
<ol>
<li>等待用户输入聊天信息</li>
<li>将信息写入管道( pipe ) 中读取, 并且发送给服务器</li>
</ol>
<p>对于父进程:</p>
<ol>
<li>使用epoll机制接受接受服务器端发过来的信息, 并显示给用户, 使用户看到其他用户的聊天信息</li>
<li>将子进程写道pipe内的信息读取出来并且发送给服务器端</li>
</ol>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ol>
<li>支持多个客户端接入，实现聊天室基本功能</li>
<li>启动服务建立监听端口等待客户端连接</li>
<li>使用epoll机制实现并发，增加效率</li>
<li>客户端连接时发送欢迎消息并存储连接记录</li>
<li>客户端发送消息时广播给其他所有客户端</li>
<li>客户端请求退出时对连接信息进行清理</li>
</ol>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>模型采用C/S模型</p>
<ul>
<li>服务器端<ol>
<li>socket()创建监听socket</li>
<li>bind()绑定服务器端口</li>
<li>listen()监听客户端连接</li>
<li>accept()接受连接</li>
<li>recv/send接受和发送数据</li>
<li>close()关闭socket</li>
</ol>
</li>
</ul>
<ul>
<li>客户端<ol>
<li>socket()创建监听socket</li>
<li>connect()连接服务器</li>
<li>recv/send接受或者传送信息</li>
<li>close()关闭socket</li>
</ol>
</li>
</ul>
<h3 id="TCP服务端通信的常规步骤"><a href="#TCP服务端通信的常规步骤" class="headerlink" title="TCP服务端通信的常规步骤"></a>TCP服务端通信的常规步骤</h3><ol>
<li>使用socket()创建TCP套接字（socket）</li>
<li>将创建的套接字绑定到一个本地地址和端口上（Bind）</li>
<li>将套接字设为监听模式，准备接收客户端请求（listen）</li>
<li>等待客户请求到来: 当请求到来后，接受连接请求，返回一个对应于此次连接的新的套接字（accept）</li>
<li>用accept返回的套接字和客户端进行通信（使用write()/send()或send()/recv() )</li>
<li>返回，等待另一个客户请求</li>
<li>关闭套接字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server.cpp代码（通信模块）：</span></span><br><span class="line"><span class="comment">// 服务端地址 ip地址 + 端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">serverAddr.sin_family = PF_INET;</span><br><span class="line">serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(SERVER_HOST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端创建监听socket</span></span><br><span class="line"><span class="keyword">int</span> listener = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(listener &lt; <span class="number">0</span>) &#123; perror(<span class="string">"listener"</span>); <span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"listen socket created \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将服务端地址与监听socket绑定</span></span><br><span class="line"><span class="keyword">if</span>( bind(listener, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"bind error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line"><span class="keyword">int</span> ret = listen(listener, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123; perror(<span class="string">"listen error"</span>); <span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Start to listen: %s\n"</span>, SERVER_HOST);</span><br></pre></td></tr></table></figure>
<p>之后会提到accept和epoll的方法</p>
<h2 id="TCP客户端通信的常规步骤"><a href="#TCP客户端通信的常规步骤" class="headerlink" title="TCP客户端通信的常规步骤"></a>TCP客户端通信的常规步骤</h2><ol>
<li>创建套接字（socket）</li>
<li>使用connect()建立到达服务器的连接（connect)</li>
<li>客户端进行通信（使用write()/send()或send()/recv())</li>
<li>使用close()关闭客户连接</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client.cpp代码（通信模块）：</span></span><br><span class="line"><span class="comment">// 客户要连接的服务端地址（ ip地址 + 端口号）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">serverAddr.sin_family = PF_INET;</span><br><span class="line">serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字（socket）</span></span><br><span class="line"><span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sock &lt; <span class="number">0</span>) &#123; perror(<span class="string">"sock error"</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发出连接请求（connect）</span></span><br><span class="line"><span class="keyword">if</span>(connect(sock, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"connect error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于客户端如何实现管道之间的通信，以及与服务端之间的通信，在后面会详细介绍。</p>
<h2 id="基本技术"><a href="#基本技术" class="headerlink" title="基本技术"></a>基本技术</h2><h3 id="阻塞和非阻塞socket"><a href="#阻塞和非阻塞socket" class="headerlink" title="阻塞和非阻塞socket"></a>阻塞和非阻塞socket</h3><p>通常的,对一个文件描述符对应的文件或者是设备, 阻塞和非阻塞方式</p>
<ol>
<li>阻塞方式指的是: 当试图对该文件描述符进行读写的时候, 如果当时没有数据可读或者暂时不可写, 那么程序就进入等待状态, 知道有东西/空间可以读/写时, 程序接受到某个信号量被唤醒重新进入就绪队列( 操作系统 )</li>
<li>如果没有资源可写或者没有数据可读, 那么直接返回, 或者等一个特定的时间片再来寻求相应的资源</li>
</ol>
<p>两者的区别就是, 是否等待某一个信号量来重新唤醒。<br>我们这个小demo采用非阻塞的socket<br>这样能够充分利用服务器性能（<del>其实是偷懒比较方便</del>）</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>当服务端的在线人数越来越多，会导致系统资源吃紧，I/O效率越来越慢，这时候就应该考虑epoll了。epoll是Linux内核为处理大批句柄而作改进的poll，是Linux特有的I/O函数。其特点如下：</p>
<ol>
<li>epoll是Linux下多路复用IO接口select/poll的增强版本。其实现和使用方式与select/poll有很多不同，epoll通过一组函数来完成有关任务，而不是一个函数</li>
<li>epoll之所以高效，是因为epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/poll每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入就绪队列的描述符集合就行了。</li>
<li>epoll有两种工作方式，LT(level triggered)：水平触发和ET(edge-triggered)：边沿触发。LT是select/poll使用的触发方式，比较低效；而ET是epoll的高速工作方式，这次demo使用epoll的ET方式。</li>
</ol>
<p>想要了解epoll的可以康康 <a href="https://www.cnblogs.com/lojunren/p/3856290.html" title="这篇博客" target="_blank" rel="noopener">这篇博客</a> ，这篇博客的参考文献也挺有读一读的价值</p>
<p>咳咳，言归正传，我们看看epoll的C/C++接口长啥样子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll句柄，参数size用来告诉内核需要监听的文件描述符的数目，这个size是有上限的，随着内核的更新可能会不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件注册函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能： epoll事件注册函数</span></span><br><span class="line"><span class="comment">　 参数epfd为epoll的句柄，即epoll_create返回值</span></span><br><span class="line"><span class="comment">　 参数op表示动作，用3个宏来表示：</span></span><br><span class="line"><span class="comment">　　  EPOLL_CTL_ADD(注册新的fd到epfd)， </span></span><br><span class="line"><span class="comment">　EPOLL_CTL_MOD(修改已经注册的fd的监听事件)，</span></span><br><span class="line"><span class="comment">　　  EPOLL_CTL_DEL(从epfd删除一个fd)；</span></span><br><span class="line"><span class="comment">　　  其中参数fd为需要监听的标示符；</span></span><br><span class="line"><span class="comment">　 参数event告诉内核需要监听的事件，event的结构如下：</span></span><br><span class="line"><span class="comment">struct epoll_event &#123;</span></span><br><span class="line"><span class="comment">  __uint32_t events; //Epoll events</span></span><br><span class="line"><span class="comment">  epoll_data_t data; //User data variable</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">其中介绍events是宏的集合，本项目主要使用EPOLLIN(表示对应的文件描述符可以读，即读事件发生)，其他宏类型，可以google之！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件的产生，我猜可能有点类似C#中的async</span></span><br><span class="line"><span class="comment">// 函数返回需要处理的事件数目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因此服务端使用epoll的时候，步骤如下：</p>
<ol>
<li>调用epoll_create函数在Linux内核中创建一个事件表；</li>
<li>然后将文件描述符（监听套接字listener）添加到所创建的事件表中；</li>
<li>在主循环中，调用epoll_wait等待返回就绪的文件描述符集合；</li>
<li>分别处理就绪的事件集合，本项目中一共有两类事件：新用户连接事件和用户发来消息事件（epoll还有很多其他事件，这里我就不深入了以后有机会再开坑</li>
</ol>
<p>把一个socket添加到事件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件描述符fd添加到epollfd标示的内核事件表中， 并注册EPOLLIN和EPOOLET事件，EPOLLIN是数据可读事件；EPOOLET表明是ET工作方式。最后将文件描述符设置非阻塞方式</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param epollfd: epoll句柄</span></span><br><span class="line"><span class="comment">  * @param fd: 文件描述符</span></span><br><span class="line"><span class="comment">  * @param enable_et : enable_et = true, </span></span><br><span class="line"><span class="comment">     采用epoll的ET工 作方式；否则采用LT工作方式</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span>( enable_et )</span><br><span class="line">        ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd added to epoll!\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我们已经进行了一系列的分析，是时候进行一波实现了，又到了我最喜欢的coding环节</p>
<p>先进行一波初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化代码文件夹</span></span><br><span class="line">$ mkdir -p /home/hallwood/Code/learning/cpp/tiny_msg_demo</span><br><span class="line">$ <span class="built_in">cd</span> /home/hallwood/Code/learning/cpp/tiny_msg_demo</span><br><span class="line">$ mkdir header cpp</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装cmake</span></span><br><span class="line">$ sudo pacman -S cmake</span><br><span class="line">$ touch CMakeLists.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对应的文件</span></span><br><span class="line">$ touch Common.h Client.h Client.cpp ClientMain.cpp</span><br><span class="line">$ touch Server.h Server.cpp ServerMain.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件到对应的文件夹</span></span><br><span class="line">$ mv *.h ./header</span><br><span class="line">$ mv *.cpp ./cpp</span><br></pre></td></tr></table></figure>
<p>每个文件的作用:</p>
<ol>
<li>Common.h: 公共头文件</li>
<li>Client.h, Client.cpp: 客户端类实现</li>
<li>Server.h, Server.cpp: 服务器端实现</li>
<li>ClientMain.cpp,和ServerMain.cpp: 分别是客户端程序和服务器端程序的执行入口</li>
</ol>
<p>接下来我们开始逐渐实现我们需要的类</p>
<h2 id="Common-h"><a href="#Common-h" class="headerlink" title="Common.h"></a>Common.h</h2><p>这个头文件是Client程序和Server程序共用的， 我们只需要定义一个单独的函数被类成员函数调用即可，这个功能函数的作用就是之前提到的将文件描述符fd添加到epollfd标示的内核事件表中，因此我们把它卸载Common.h中，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/stl-analysis1-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/01/stl-analysis1-md/" class="post-title-link" itemprop="url">STL源码学习 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-01 02:58:20" itemprop="dateCreated datePublished" datetime="2018-12-01T02:58:20+08:00">2018-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以STL的运用角度而言,空间配置器是最不需要介绍的东西,它总是隐藏在一切组件后面，组件的实作时处处遇到挡路石。为什么不说allocator是内存配置器而说它是空间配置器呢?因为,空间不一定是内存,空间也可以是磁盘或其它辅助储存媒体。是的,你可以写一个 allocator,直接向硬盘取空间。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line">allocator::rebind</span><br><span class="line"><span class="comment">// 一个巢状的(nested)class template。class rebind&lt;U&gt;拥有唯一成员other,</span></span><br><span class="line"><span class="comment">// 那是一个 typedef,代表allocator&lt;U&gt;。</span></span><br><span class="line">allocator::allocator()</span><br><span class="line"><span class="comment">// default constructor。</span></span><br><span class="line">allocator::allocator(<span class="keyword">const</span></span><br><span class="line"> allocator&amp;)</span><br><span class="line"><span class="comment">// copy constructor。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;<span class="title">allocator</span>:</span>:allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span><br><span class="line"><span class="comment">// 泛化的copy constructor。</span></span><br><span class="line">allocator::~allocator()</span><br><span class="line"><span class="comment">// default constructor。</span></span><br><span class="line">pointer allocator::address(reference x) <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 传回某个对象的地址。算式a.address(x)等同于&amp;x。</span></span><br><span class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 传回某个const对象的地址。算式a.address(x)等同于&amp;x。</span></span><br><span class="line"></span><br><span class="line">pointer allocator::allocate(size_type n, cosnt <span class="keyword">void</span>* = <span class="number">0</span>)</span><br><span class="line"><span class="comment">//配置空间,足以储存n个T对象。第二自变量是个提示。实作上可能会利用它来</span></span><br><span class="line"><span class="comment">//增进区域性(locality),或完全忽略之。</span></span><br><span class="line"><span class="keyword">void</span> allocator::deallocate(pointer p, size_type n)</span><br><span class="line"><span class="comment">//归还先前配置的空间。</span></span><br><span class="line">size_type allocator::max_size() <span class="keyword">const</span></span><br><span class="line"><span class="comment">//传回可成功配置的最大量。</span></span><br><span class="line"><span class="keyword">void</span> allocator::construct(pointer p, <span class="keyword">const</span> T&amp; x)</span><br><span class="line"><span class="comment">//等同于new(const</span></span><br><span class="line"><span class="comment">// void*) p) T(x)。</span></span><br><span class="line"><span class="keyword">void</span> allocator::destroy(pointer p)</span><br><span class="line"><span class="comment">// 等同于p-&gt;~T()。</span></span><br></pre></td></tr></table></figure>
<h3 id="自己设计实现一个最简单的空间适配器"><a href="#自己设计实现一个最简单的空间适配器" class="headerlink" title="自己设计实现一个最简单的空间适配器"></a>自己设计实现一个最简单的空间适配器</h3><p><a href="https://github.com/HallWoodZhang/fakestl" title="代码" target="_blank" rel="noopener">代码</a> 文件分别是demo/simpleAllocator0.cpp和demo/simpleAllocator0.h</p>
<p>头文件，在这里std::set_new_handler我没有指派函数给他，所以其实allocator::allocate函数的第二个参数暂时不用理会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simpleAllocator0.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SALLOCATOR_0__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SALLOCATOR_0__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA0 &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> T* _allocate(<span class="keyword">ptrdiff_t</span> size, T* hint) &#123;</span><br><span class="line">        <span class="built_in">std</span>::set_new_handler(<span class="number">0</span>);</span><br><span class="line">        T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size*<span class="keyword">sizeof</span>(T))));</span><br><span class="line">        <span class="keyword">if</span>(!tmp) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of mem"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _deallocate(T* buffer) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _construct(T1* p, <span class="keyword">const</span> T2&amp; val) &#123;</span><br><span class="line">        <span class="keyword">new</span>(p) T1(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> _destroy(T* p) &#123;</span><br><span class="line">        p-&gt;~T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">            <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* hint = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span> </span>&#123;</span><br><span class="line">            _deallocate(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">            _construct(p, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;</span><br><span class="line">            _destroy(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (const_pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size_type(UINT_MAX/<span class="keyword">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// end of class allocator</span></span><br><span class="line">&#125; <span class="comment">// end of namespace SA0;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>测试文件simpleAllocator0.cpp，申明一个vector，并且指派自己写的Allocator作为空间适配器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SA0::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia, ia+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"simpleAllocator0.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SA0::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia, ia+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./simpleAllocator0 </span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2 id="具备次配置力-sub-allocation-的-SGI-空间配置器"><a href="#具备次配置力-sub-allocation-的-SGI-空间配置器" class="headerlink" title="具备次配置力( sub-allocation)的 SGI 空间配置器"></a>具备次配置力( sub-allocation)的 SGI 空间配置器</h2><p>由于《STL源码剖析》这本书解读的是SGI版本的STL设计实现，所以我们需要看一些有关方面的特殊实现方法，SGI STL 的配置器与众不同 , 也与标准规范不同 , 其 名 称 是alloc而非allocator,而且不接受任何自变量。换句话说如果你要在程序中明白采用SGI配置器,不能采用标准写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt; iv;<span class="comment">//in VC or CB</span></span><br></pre></td></tr></table></figure>
<p>必须这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::alloc&gt; iv;  <span class="comment">// in GCC</span></span><br></pre></td></tr></table></figure>
<h3 id="SGI-标准的空间配置器-标准的空间配置器-std-allocator"><a href="#SGI-标准的空间配置器-标准的空间配置器-std-allocator" class="headerlink" title="SGI 标准的空间配置器, 标准的空间配置器, std::allocator"></a>SGI 标准的空间配置器, 标准的空间配置器, std::allocator</h3><p>虽然 SGI 也定义有一个符合部份标准、名为allocator的配置器,但SGI自己从未用过它,也不建议我们使用。主要原因是效率不彰,只把 C++的::operator new和::operator delete做一层薄薄的包装而已。下 面是SGI的std::allocator 全貌：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们不赞成含入此文件。这是原始的 HP default allocator。提供它只是为了</span></span><br><span class="line"><span class="comment">//回溯相容。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DO NOT USE THIS FILE 不要使用这个文件,除非你手上的容器是以旧式作法</span></span><br><span class="line"><span class="comment">//完成—那就需要一个拥有 HP-style interface的空间配置器。SGI STL使用</span></span><br><span class="line"><span class="comment">//不同的 allocator界面。SGI-style allocators 不带有任何与对象型别相关</span></span><br><span class="line"><span class="comment">//的参数;它们只回应 void*指标(侯捷注:如果是标准接口,就会响应一个</span></span><br><span class="line"><span class="comment">//「指向对象型别」的指针,T*)。此文件并不含入于其它任何 SGI STL头文件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    set_new_handler(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size * <span class="keyword">sizeof</span>(T))));</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>) &#123;</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> ::allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p)</span> </span>&#123; ::deallocate(p); &#125;</span><br><span class="line">    <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123; <span class="keyword">return</span> (pointer)&amp;x; &#125;</span><br><span class="line">    <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">init_page_size</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(<span class="number">4096</span>/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(UINT_MAX/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本(specialization)。注意,为什么最前面不需加template&lt;&gt;?</span></span><br><span class="line"><span class="comment">//见 1.9.1 节的组态测试。注意,只适用于 GCC。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的两行注释是候捷写的，我自己测了不行，还是要按照标准来</span></span><br><span class="line"><span class="comment">// 然而事实上，我使用gcc8.2.0测试，这条是通不过的，还是需要加上template&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in gcc 8.2.0</span></span><br><span class="line"><span class="comment">// template&lt;&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span>&lt;void&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SGI特殊的空间配置器std-alloc"><a href="#SGI特殊的空间配置器std-alloc" class="headerlink" title="SGI特殊的空间配置器std::alloc"></a>SGI特殊的空间配置器std::alloc</h3><p>上一次所写到，也就是SGI中的Allocator只是对于::operator delete和::operator new的一个简单的包装，并没有任何效率上的优化，其在文档中也不建议我们來直接使用这个allocator</p>
<p>一般的，我们使用C++来构建对象的过程是如下的一个过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> demo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo* pfoo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">delete</span> pfoo;</span><br></pre></td></tr></table></figure>
<p>这其中的new算式内包含两个阶段的动作：</p>
<ol>
<li>call ::operator new配置内存</li>
<li>call Foo::Foo()函数来构建对象内容</li>
</ol>
<p>delete语句内也包含了两个动作</p>
<ol>
<li>call Foo::~Foo()函数析构对象</li>
<li>call ::operator delete来释放内存</li>
</ol>
<p>STL的标准告诉我们，配置器的定义在”memory”这个头文件中，在SGI版本的memory有包含两个文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt; // 负责空间的分配和释放</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt; // 负责内容的构建和析构</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stl_uninitialized.h&gt; 这个之后再说</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这里定义有一些全域函式,用来充填(fill)</span></span><br><span class="line"><span class="comment">	或复制(copy)大块内存内容,它们也都</span></span><br><span class="line"><span class="comment">	隶属于 STL 标准规范:</span></span><br><span class="line"><span class="comment">	un_initialized_copy()</span></span><br><span class="line"><span class="comment">	un_initialized_fill()</span></span><br><span class="line"><span class="comment">	un_initialized_fill_n()</span></span><br><span class="line"><span class="comment">    这些函式虽不属于配置器的范畴,但与对象初值</span></span><br><span class="line"><span class="comment">    设定有关,对于容器的大规模元素初值设定很有</span></span><br><span class="line"><span class="comment">    帮助。这些函式对于效率都有面面俱到的考虑,</span></span><br><span class="line"><span class="comment">    最差情况下会呼叫construct(),</span></span><br><span class="line"><span class="comment">    最佳情况则使用C标准函式memmove() 直接进行</span></span><br><span class="line"><span class="comment">    内存内容搬移。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这两个文件分别负责一个对象的出生/消亡的两个步骤，在stl_construct函数中定义了construct()和destroy()这两个基本的函数</p>
<h3 id="构造和析构的基本工具：-construct-和destroy"><a href="#构造和析构的基本工具：-construct-和destroy" class="headerlink" title="构造和析构的基本工具： construct()和destroy()"></a>构造和析构的基本工具： construct()和destroy()</h3><p>我们先看看在&lt;stl_construct.h&gt;中的部分内容</p>
<p>我们以两个模板参数版本的construct()函数为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向__p指向的内存塞入一个用_T1::_T1(const _T2&amp; __val)函数构造的对象</span></span><br><span class="line"><span class="comment">// 这个功能在头文件&lt;new&gt;中有</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">	<span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1(__value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">	_Construct(__p, __value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以迭代取版本和指针版本的destroy函数为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 第一对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">	__pointer-&gt;~_Tp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">	_Destroy(__pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	_Destroy(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	__destroy(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>补充说明：<br>对于某一个对象，如果用户不定义析构函数，而是用系统自带的，则说明，析构函数基本没有什么用（但默认会被调用）我们称之为trivial destructor。反之，如果特定定义了析构函数，则说明需要在释放空间之前做一些事情，则这个析构函数称为non-trivial destructor。如果某个类中只有基本类型的话是没有必要调用析构函数的，delelte p的时候基本不会产生析构代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对于具有trivial析构函数的对象，不用p-&gt;~T()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span>, _<span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象具有non-trivial析构函数，需要显式的析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    	destroy(&amp;*__first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外的一些对象的destoy函数的特化版，实际上，它们什么都没做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">char</span>*, <span class="keyword">char</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">int</span>*, <span class="keyword">int</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">long</span>*, <span class="keyword">long</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">float</span>*, <span class="keyword">float</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">double</span>*, <span class="keyword">double</span>*) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_HAS_WCHAR_T</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_HAS_WCHAR_T */</span></span></span><br></pre></td></tr></table></figure>
<p>显然的，这些数据经过“摧毁”后，真的消失了吗？并没有，他们还在内存里面，只不过他们所占用的位置被某种方式定为“没有被使用过的”内存区域了（我还没看到书中关于这方面的解释，可能后面会有），这就是为什么我们每次定义一个基本类型的对象，如果未初始化，那么它的值还有上一次销毁的数据的影子，就像“幽灵”一样</p>
<p>又有人要问了，这些函数什么都不做，会不会太不负责任？准备将[first,last) 范围内的所有对象析构掉。我们不知道这个范围有多大,万一很大,而每个物件的解构式都无关痛痒(所谓 trivial-destructor),那么一次次呼叫这些无关痛痒的解构式,对效率有不利影响。因此,这里首先利用value_type()获得迭代器所指物件的型别,再 利 用”type_traits<t>“判 别 该 型 别 的 解 构 式 是 否 无 关 痛 痒 。 若 是true_type,什么也不做就结束;若否false_type,这才以循环方式巡访整个范围,并在循环中每经历一个对象就呼叫第一个版本的 destroy()。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	__destroy(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的想法是很好,但 C++本身并不直接支持对「指标所指之物」的型别判断」，那么VALUE_TYPE(__first)是什么？我们之后再讨论这个问题</p>
<h3 id="空间的配置和释放-std-alloc-in-SGI-STL"><a href="#空间的配置和释放-std-alloc-in-SGI-STL" class="headerlink" title="空间的配置和释放 std::alloc in SGI-STL"></a>空间的配置和释放 std::alloc in SGI-STL</h3><p><strong>注意，我们讨论的是SGI-STL版本，不是标准版本</strong></p>
<p>大致的看完了内存配置后的对象构建行为，和内存对象的析构行为，现在我们来到了内存的分配和释放</p>
<p>对象构建前的空间配置，和对象析构之后的空间回收有stl_alloc.h负责</p>
<p>SGI-STL对此的设计哲学如下：</p>
<ol>
<li>向system heap要更多的空间</li>
<li>更多的考虑多线程的情况（multi-thread）</li>
<li>考虑内存不足的应对</li>
<li>考虑过多「小型区域」的申请造成的内存碎片问题（fragment）</li>
</ol>
<p>为了我和你的小心脏和不聪明的脑袋，我尽量在接下来讨论排除multi-thread状态的情况</p>
<p><strong>台湾程序员把allocator叫配置器，我们这边就按他这么叫吧，嘻嘻</strong></p>
<p>C++ mem分配的基本操作是::operator new(), mem 的释放基本操作是::operator delete()。这两个全局函数相当于C中的malloc和free()，正是因为此，SGI-STL中使用了malloc和free函数</p>
<p>考虑到「小型区域」的多次分配招成的内存碎片问题，SGI-STL设计了双层级配置器，第一级直接使用了malloc和free，第二级则视情况的不同采用了不同的策略</p>
<p>当分配的内存超过128 Bytes，视为「足够大的内存申请」，便直接调用第一级的配置器，反之，我们认为这个请求是「小内存申请请求」，为了降低额外负担，便采用了复杂的整理方式整理内存池，而不是直接调用第一级的空间配置器</p>
<p>整个设计究竟只开放第一级配置器,或是同时开放第二级配置器,取决USE_MALLOC是否被定义(唔,我们可以轻易测试出来,SGI STL并未定义USE_MALLOC):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc single_client_alloc;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure>
<p>无论alloc被定义为第一级或第二级配置器,SGI还为它再包装一个接口如下,<br>使配置器的接口能够符合 STL规格:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> _<span class="function">Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*) _Alloc::allocate(__n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="keyword">static</span> _<span class="function">Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (_Tp*) _Alloc::allocate(<span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::deallocate(__p, __n * <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">      </span>&#123; _Alloc::deallocate(__p, <span class="keyword">sizeof</span> (_Tp)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SGI-STL第一级空间分配器的大致工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span> </span><br><span class="line">	<span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>allocate()成员函数直接使用C-type malloc函数</li>
<li>deallocate()成员函数直接使用C-type free函数</li>
<li>模拟C++中的std::set_new_handler来处理内存不足的情况</li>
</ol>
<p>SGI-STL第二季空间配置器的大致工作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>负责维护16个自由串行表，来维护16种小型内存块的分配，内存池以malloc来获得（调用第一级malloc一个大的内存块），如果申请的内存池不足，呼叫调用第一级适配器以获得更大的内存池</li>
<li>如果申请的内存大于128bytes那么直接调用第一级空间配置器</li>
</ol>
<h3 id="第一级适配器-malloc-alloc-template-解析"><a href="#第一级适配器-malloc-alloc-template-解析" class="headerlink" title="第一级适配器 malloc_alloc_template 解析"></a>第一级适配器 malloc_alloc_template 解析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THROW_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> __THROW_BAD_ALLOC fprintf(stderr, <span class="meta-string">"out of memory\n"</span>); exit(1)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span> <span class="comment">/* Standard conforming out-of-memory handling */</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> __THROW_BAD_ALLOC throw std::bad_alloc()</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>类的定义（这里用的直接是SGI_STL的源码，代码风格就是这样有很多下划线）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 一般而言，是thread-safe的</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当没有足够的内存的时候的处理函数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个简单的函数指针 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 非常直接，直接申请空间，出错交给oom_handler处理</span></span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 对free的简单包装</span></span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 同allocate的处理方式  </span></span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下模拟 C++的 set_new_handler(). 换句话说，你可以透过它，</span></span><br><span class="line">  <span class="comment">//指定你自己的 out-of-memory handler</span></span><br><span class="line">  <span class="comment">// 这段代码看不懂的可以看看这个分析</span></span><br><span class="line">  <span class="comment">// https://glemontree.github.io/2017/10/23/[C++]%20static%20void%20(%20__set_malloc_handler(void%20(__f)()))()/</span></span><br><span class="line">  <span class="comment">// 拆开一层一层的分析，最内部的__f是一个函数指针，其参数为void，返回值为void。</span></span><br><span class="line">  <span class="comment">// 对于__set_malloc_handler，首先它是一个函数，其参数为形如__f的函数指针，其返回值也是一个指针，这个指针的类型是void(*)()</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">( * __set_malloc_handler( <span class="keyword">void</span> (*__f)() ) )</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于初始out-of-mem handler的设置，直接设置为nullptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 不断的配置，知道分配到新的内存为止</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化__inst = 0的情况 __malloc_alloc_template&lt;0&gt;为malloc_alloc;</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>
<p>第一级空间分配器以，malloc，free，realloc等C函数执行实际的内存的分配，释放重释放过程。并且作出类似std::set_new_handler()的机制，而不是实际调用C++ std::set_new_handler()组件，因为SGI-STL并没有使用::operator new和::opertor delete来分配和释放内存。</p>
<p>所谓 C++ new handler 机制是,你可以要求系统在内存配置需求无法被满足时,<br>唤起一个你所指定的函式。换句话说一旦::operator new无法达成任务,在丢出去std::bad_alloc异常状态之前，会先调用程序员指定的out_of_mem_handler函数，这个可以由程序员自己编写。</p>
<p>为什么SGI_STL不采用C++标准的::operator new()和::operator delete()作为分配和释放内存的原子操作呢？个人认为可能有以下两点原因：</p>
<ol>
<li>C++ 并没有提供一个类似于realloc的一个充分配动作</li>
<li>一些历史因素</li>
</ol>
<p>所以SGI_STL不使用::operator new和delete，连带的，也就不能使用std::set_new_handler这个组件来对应处理内存不够的情况，为此，SGI-STL的作者自己实现了一个类似的机制</p>
<p>需要注意的是，SGI-STL的第一级空间分配器allocate和reallocate都是在malloc和realloc两个C-type函数不成功以后才会调用S_oom_alloc和S_oom_realloc这两个函数，这两个函数有一个内循环会不停的尝试申请新的内存，知道成功为止，但是当程序员并没有设置malloc_alloc_oom_handle这个函数指针，那么，THROW_BAD_ALLOC就会被执行（这个宏具体就是抛出异常并exit当前进程）</p>
<p>设计内存不足的时候的处理程序是使用者程序员的责任，据说解决这个问题有一套特定的模式，这里就不再细究了。</p>
<h3 id="第二级空间分配器"><a href="#第二级空间分配器" class="headerlink" title="第二级空间分配器"></a>第二级空间分配器</h3><p>第二级空间分配器相比第一级简陋的分配器，有了许多的机制和判断逻辑。小区域动态内存的申请带来的不仅仅是内存碎片的问题，分配的时候，每一片内存的额外负担也是一个很大的问题，毕竟系统要靠这个来管理内存，先前我们提到，很多情况下内存在数据中并没有消失，只是被以某种形式记录为“未被使用的”，假设我们要给一个指针pa申请一块动态的内存空间，那么在pa = new object()，执行之后pa所指的内存空间存在着一个object()默认构造函数构造过的对象，但是在pa - (cookie_size)所指向的空间中存在一个用来记录pa大小和是否被使用的记录数据块（cookie），这也就是说每次申请x bytes内存，<strong>实际上就有x + cookie_size bytes的内存被申请</strong>，这也就意味着，x越小，内存的利用效率越低</p>
<p>而SGI-STL的第二级分配器做法是，如果区域足够大，超过了128bytes,那么就移交给第一级适配器，当申请的内存区域小于128bytes时，则使用内存池（memory pool）来管理这些小的内存块，这种方法又被称为sub-allocation：</p>
<ul>
<li>每次都分配一块很大的内存区域，并且使用空闲列表free_list来管理</li>
<li>如果用户有小区域内存的需求，直接从free_list中找到空闲的结点（空闲的块，有点像文件系统中datanode）</li>
<li>如果用户释放小型内存区域，则直接将这块大小的内存并入free_list链表</li>
<li><strong>需要注意的是，在这种机制下无论分配还是释放，free_list都会把申请的内存区域整理为8 bytes的整数倍（打个比方，用户申请30bytes的内存空间，那么allocator会充free_list_32bytes_sz中分配一个32bytes的可用内存给用户，用户如果释放30bytes内存，那么allocator会强行把后面附加的2bytes也一并回收）</strong>，allocator维护16个free_list链表，分别负责8,16,24,32,40,48 … 128 bytes的内存分配和释放，free_list类似结构如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> free_list_node_bytes &#123;</span><br><span class="line">    <span class="keyword">union</span> free_list_node_bytes* next;</span><br><span class="line">    <span class="keyword">char</span> data_area[SIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于C-type代码足够的灵活，使用union我们不用担心指针的额外开销，这么骚的操作你在Java这种强类型语言中是绝对看不到的233</p>
<p>下面，让我们来康康第二级SGI-STL空间配置器大致的实现吧，由于我个人认为书中的代码相比其实际代码可读性（主要是原代码宏还有下划线太多啦，还涉及到一些多线程方面的情况）更好并且原理上是一样的，这里直接贴书上的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;<span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;<span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="comment">//free-lists个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是第二级配置器。</span></span><br><span class="line"><span class="comment">//注意,无「template 型别参数」,且第二参数完全没派上用场。</span></span><br><span class="line"><span class="comment">//第一参数用于多绪环境下。本书不讨论多绪环境。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> ints&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">defaut_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// ROUND_UP函数把bytes上调至8的整数倍</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 要好好复习一下单目运算	</span></span><br><span class="line">		<span class="comment">// new_bytes = 8n + x + 7 &amp; 7</span></span><br><span class="line">		<span class="comment">// if x == 0 new_bytes = 8n</span></span><br><span class="line">		<span class="comment">// else if x &gt; 0 then x + 7 &gt;= 8 产生进位故(8n + x + 7 &amp; 7) == (8n + 8)</span></span><br><span class="line">		<span class="keyword">return</span> (((bytes) + __ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)__ALIGN - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj* free_list_link;</span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// volatile不知道什么意思的请使用Google搜索</span></span><br><span class="line">	<span class="comment">// 或看看这篇博客：https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html</span></span><br><span class="line">	<span class="comment">// 16个free list</span></span><br><span class="line">	<span class="keyword">static</span> obj* <span class="keyword">volatile</span> free_list[____NFREELISTS];</span><br><span class="line">	<span class="comment">// 下面根据函数区块大小，决定使用第N个free_list;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// eg: 8 + 7 = 15, 15 / 8 = 1, 1 - 1 = 0</span></span><br><span class="line">		<span class="comment">// 这是程序员经常使用的一条数学式子</span></span><br><span class="line">		<span class="keyword">return</span> (((bytes) +__ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 传回一个大小是N的对象，并可能加入大小为n的其他区块到free_list</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分配一个大块空间可容纳 nobjs 个大小为 "size" 的区块。</span></span><br><span class="line">	<span class="comment">// 如果配置 nobjs个区块有所不便,nobjs可能会降低。</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Chunk allocation state.</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* start_free;<span class="comment">//记忆池起始位置。只在 chunk_alloc()中变化</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* end_free;<span class="comment">//记忆池结束位置。只在 chunk_alloc()中变化</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="comment">/* 之后再讨论 */</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span> </span>&#123; <span class="comment">/* 之后再讨论 */</span> &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能初始化的时候这么干</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, <span class="keyword">bool</span>&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads, <span class="keyword">bool</span>&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] = </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="空间分配函数allocator"><a href="#空间分配函数allocator" class="headerlink" title="空间分配函数allocator()"></a>空间分配函数allocator()</h4><p>身为一个空间分配器，default_alloc_template拥有分配器的标准接口allocate()。这个函数首先判断申请的内存区域的大小，大于128bytes会调用第一级空间分配器，否则就检查对应的free_list，如果free_list有空闲的区块，那么直接分配空闲区块，如果没有足够的空闲区块，则调整区块大小至8的倍数，然后调用本类内的refill函数，重新为free_list填充足够的内存空间</p>
<p>在default_alloc_template类内<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这是一个二级指针</span></span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj* result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大于128bytes则直接调用第一级的空间分配器</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找16个free_list中合适的那一个</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        <span class="comment">// 没有找到可用的free_list</span></span><br><span class="line">        <span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配完free_list结点之后</span></span><br><span class="line">    *my_free_list = result-&gt;free_list_link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空间释放器deallocator"><a href="#空间释放器deallocator" class="headerlink" title="空间释放器deallocator()"></a>空间释放器deallocator()</h4><p>default_alloc_template拥有便准的deallocate()。这个函数首先判断处理的内存区块的大小，大于128 bytes就呼叫第一级的空间释放器，小于128bytes就找出对应的free_list，并且将区块回收</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p != nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    obj* q = (obj* ) p;</span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::deallocate(p, n);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找对应的free_list</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整free_list</span></span><br><span class="line">    q -&gt; free_list_link = *my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收区块</span></span><br><span class="line">    *my_free_list = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重新填充free-list-refill"><a href="#重新填充free-list-refill" class="headerlink" title="重新填充free_list: refill"></a>重新填充free_list: refill</h4><p>我们之前讨论过的，就是当申请内存的时候，当free_list不够用的时候，当它发现free_list就调用refill()准备为free_list重新填充空间。新的空间将取自内存池，内存池的申请由chunk_alloc来完成。预设取得20个新结点，但是万一内存池空间不足获得的结点数可能要小于20</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传回一个大小是n的对象，并且有时候会为free_list填充适当的结点</span></span><br><span class="line"><span class="comment">// 我们假设n已经上调至8的整数倍</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> ints&gt;</span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, ints&gt;::refill(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 调用chunk_alloc()，取得nobjs个区块作为free_list的新结点</span></span><br><span class="line">    <span class="comment">// 值得注意的是nobjs是一个引用传值参数</span></span><br><span class="line">    <span class="keyword">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">    obj* result;</span><br><span class="line">    obj* current_obj;</span><br><span class="line">    obj* next_obj;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果只获得一个区块，这个区块就拨给调用者使用free_list并没有增加任何新的结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则准备调整free_list，纳入新的结点</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下在chunk空间内建立free_list</span></span><br><span class="line">    result = (obj*)chunk;</span><br><span class="line">    </span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下free_list各个结点串接起来</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; ;++i) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj*)((<span class="keyword">char</span>*) next_obj + n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存池分配chunk-alloc"><a href="#内存池分配chunk-alloc" class="headerlink" title="内存池分配chunk_alloc"></a>内存池分配chunk_alloc</h4><p>从内存池中取得新的空闲空间给free list使用，这是chunk_alloc的职责：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设size已经上调至8的整数倍</span></span><br><span class="line"><span class="comment">// nobjs是一个引用参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size*nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line">    <span class="keyword">if</span>(bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        <span class="comment">// 当内存池的容量还满足需求的时候</span></span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// 当内存池的空间不够,但是能够供应一个以上的size空间的时候</span></span><br><span class="line">        nobjs = bytes_left / size;</span><br><span class="line">        total_bytes = size*nobjs;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当内存池剩余空间连一个块都无法提供的时候</span></span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span>*total_bytes + (ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 以下操作试图利用残余的小内存池空间</span></span><br><span class="line">        <span class="keyword">if</span>(bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 内存池中还有一些零头</span></span><br><span class="line">            <span class="comment">// 我在这里卡了一会，因为无法理解如果内存池内剩余的空间不足8bytes的情况下这么写怎么会行的通，后来我想通了。</span></span><br><span class="line">            <span class="comment">// 因为无论是内存池的申请还是使用，都是以8bytes的整数倍为单位进行的，当还有剩余空间的时候，它必然是8bytes的整数倍，这句if语句你可以理解为if(bytes_letft &gt;0 &amp;&amp; bytes_left &gt;= 8)</span></span><br><span class="line">            obj* <span class="keyword">volatile</span>* my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">            ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">            *my_free_list = (obj*)start_free;</span><br><span class="line">        &#125; <span class="comment">// end if</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置Heap空间</span></span><br><span class="line">        start_free = (<span class="keyword">char</span>* )<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == start_free) &#123;</span><br><span class="line">            <span class="comment">// heap空间不足,malloc失败</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">            obj *p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试检查我们手头拥有的东西</span></span><br><span class="line">            <span class="comment">// 我们不打算分配较小的内存块，因为那在多进程机器上容易造成灾难性的后果</span></span><br><span class="line">            <span class="comment">// 搜索适当的free_list</span></span><br><span class="line">            <span class="comment">// 所谓适当是指「还有没有使用的区块，且区块够大」的free_list</span></span><br><span class="line">            <span class="keyword">for</span>(i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">                p = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != p) &#123;</span><br><span class="line">                    <span class="comment">// 这个free_list还有空闲的区块</span></span><br><span class="line">                    *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                    start_free = (<span class="keyword">char</span>*) p;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 递归调用自己来修正nobjs</span></span><br><span class="line">                    <span class="keyword">return</span> chunk(size, nobjs);</span><br><span class="line">                &#125; <span class="comment">// end if</span></span><br><span class="line">            &#125; <span class="comment">// end for</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果经过上面的挣扎还没有办法得到内存并return退出函数</span></span><br><span class="line">            <span class="comment">// 只能调用第一级内存分配器了，因为第一级分配器函数有out-of-memory处理机制（之前提到的）</span></span><br><span class="line">            end_free = <span class="number">0</span>;</span><br><span class="line">            start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">        &#125; <span class="comment">// end of if(0 == start_free)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可喜可贺，如果malloc成功了，你可以不用理会那么多</span></span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + heap_size;</span><br><span class="line">        <span class="comment">// 递归调用自己以修正nobjs</span></span><br><span class="line">        <span class="keyword">return</span> chunk_alloc(size, nobjs);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// end if...else if ... else ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数看得我心情澎湃，居然代码还可以这么写</p>
<p>我们简单的总结一下，chunk_alloc它具体都作了一些什么</p>
<ul>
<li>判断内存池的剩余空间end_free - start_free<ul>
<li>如果有足够的剩余空间给20个size使用，那么直接划拨给用户20个size的chunk</li>
<li>不够20个的，但至少能够分配一个的，能分配几个就分配几个size的区块</li>
<li>内存池连一个size都拿不出来，穷得叮当响，那么把剩余内存池空间放入free_list（由于内存池无论是是申请还是使用都是8bytes的整数倍为单位进行操作的，所以剩余的空间一定是8bytes的整数倍，可以直接放入free_list），这种情况下我们再进行以下动作<ul>
<li>直接用malloc申请一个新的内存池<ul>
<li>申请成功，以新的内存池为基础，递归调用自己并返回修正nobjs</li>
<li>申请失败，寻找是否有剩余的free_list空间，要求他把吃掉的内存吐出来，如果这样还是找不到合适的内存，那么万念俱灰，变成咸鱼（把事情推给别人去做），交给第一级分配器去处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义了五个全局函数，作用在未初始化的内存空间中，这样的功能呢个对于容器的实际构造很有帮助。我们看到除了之前提到过得construct和destroy函数之外，还有三个用来使用大段内存初始化容器的函数，分别是uninitialized_copy(), uninitialized_fill(), uninitialized_fill_n()，分别对应于高阶函数copy，fill，fill_n。你在实际使用中应该包含在”memory”头文件中，不过我们本地保存的SGI-STL代码把他们的实现放到了stl_uninitialized</p>
<h3 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) ;</span></span><br></pre></td></tr></table></figure>
<p>uninitialized_copy() 使我们能够将内存的配置与对象的构造行为分离开，如果作为输出目的地 [result, result + (last - first)) 左闭右开范围内的每一个迭代器都指向一个未经过初始化或者构造的对象区域，则uninitialized_copy函数会使用复制构造函数，分别以[first, last)左闭右开区间内的每一个对象复制构造到result所指的区间内。,针对输入范围内的每一个迭代器 i,此函式会调用construct(&amp;<em>(result+(i-first)),</em>i) ,产生*i的复制品,放置于输出范围的相对位置上。</p>
<p>C++标准要求uninitialized_copy的行为是：</p>
<ul>
<li>如果所有的复制构造函数都成功运行，那么构造成功</li>
<li>如果其中有一个失败了，你不仅不能继续构建下去，甚至还要想办法回退(rollback)</li>
</ul>
<h3 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ForwardIterator, class T&gt;</span><br><span class="line">void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T&amp; x);</span><br></pre></td></tr></table></figure>
<p>行为：</p>
<ul>
<li>在 [first, last) 区间为每一个对象使用x作为引用参数调用赋值构造函数</li>
<li>不成功就回退，这点和uninitialized_copy有点类似</li>
</ul>
<p>uninitialized_copy()和uninitialized_fill()必须具备”commit or rollback”语意,换句话说它要不就产生出所有必要元素,要不就不产生任何元素。<br>如果有任何一个copy constructor丢出异常(exception),uninitialized_fill()<br>必须能够将已产生之所有元素解构掉。</p>
<h3 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>);</span></span><br></pre></td></tr></table></figure>
<p>行为：</p>
<ul>
<li>和uninitialized_fill本质上意思是一样的，只不过区间的表达方法不一样</li>
<li>也具有commit-or-rollback语义特性</li>
</ul>
<p>具体实现之后放出，它们依赖于一种叫做POD（plain old data）的布尔模板参数来判断函数泛化后的不同实现</p>
<p>所谓POD，我说的直白一点，就是C-type的struct类似的类,它的每一个成员变量都是紧贴在一起的且没有别的“杂质”字节，比如虚指针和函数指针什么的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> <span class="title">tmp</span> = (<span class="title">struct</span> <span class="title">Tmp</span>)&#123;</span><span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;; <span class="comment">// 这样初始化可行</span></span><br><span class="line"><span class="keyword">char</span>* p = ((<span class="keyword">char</span>*)&amp;tmp) + <span class="number">2</span>;</span><br><span class="line">*p == <span class="string">'c'</span>; <span class="comment">// true</span></span><br><span class="line">*p = <span class="string">'k'</span>;</span><br><span class="line">tmp.c == k; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>struct Tmp就是POD类型的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以fill_n版本的实现为例</span></span><br><span class="line"><span class="comment">// 第三级调用POD版本，直接调用高阶函数fill_n</span></span><br><span class="line"><span class="comment">// fill_n和其他两个高阶函数，我们以后会讨论</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 当__x是POD直接调用fill_n</span></span><br><span class="line">  <span class="keyword">return</span> fill_n(__first, __n, __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三级调用非POD形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _ForwardIter __cur = __first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="comment">// 当__x并不是POD的时候，老老实实的调用构造函数来复制</span></span><br><span class="line">    <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__cur)</span><br><span class="line">      _Construct(&amp;*__cur, __x);</span><br><span class="line">    <span class="keyword">return</span> __cur;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 你好，你有成员构造函数执行失败了，请回滚</span></span><br><span class="line">  __STL_UNWIND(_Destroy(__first, __cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二级调用在这里发生</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Tp1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>, _<span class="title">Tp1</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里才是入口哦,第一级调用在这里发生</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> </span></span><br><span class="line"><span class="class"><span class="title">uninitialized_fill_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">x</span>) &#123;</span></span><br><span class="line">	<span class="keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现：又出现了，那个玄学value_type()，还有is_pod判定函数，这个要到书的后面才会讲实现原理。</p>
<ul>
<li>用户调用uninitialized_fill_n</li>
<li>uninitialized_fill_n 调用 __uninitialized_fill_n</li>
<li><strong>uninitialized_fill_n 调用 </strong>uninitialized_fill_n_aux</li>
<li>__uninitialized_fill_n_aux根据复制来源是否是POD来选择显式的调用构造函数并且显式的回滚，还是直接调用fill_n来填充内存</li>
</ul>
<p>而至于没有讲到的uninitialized_copy和uninitialized_fill，大致的行为都是类似的</p>
<p>至此我们这一个章节暂时告一段落，永远不要停止学习！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/26/stl_analysis0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/26/stl_analysis0/" class="post-title-link" itemprop="url">关于STL代码学习和实践(0)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-26 22:20:47" itemprop="dateCreated datePublished" datetime="2018-11-26T22:20:47+08:00">2018-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="准备开一个学习STL代码并且自己实现的新坑啦！"><a href="#准备开一个学习STL代码并且自己实现的新坑啦！" class="headerlink" title="准备开一个学习STL代码并且自己实现的新坑啦！"></a>准备开一个学习STL代码并且自己实现的新坑啦！</h1><p>STL的有些内部实现还是很值得学习的，而且学会如何造一些比较基础的轮子也对进一步加深对自己所学知识的理解也是很有好处的</p>
<p>参考书籍是《STL源码剖析》，候捷写的，听说这本写的不错，同时我会借鉴一些Github上已经有人写出来的 <a href="https://github.com/zouxiaohang/TinySTL" title="微型版本" target="_blank" rel="noopener">微型版本</a> 来加深我对于这些源代码的理解</p>
<p>再加上我自己从网上搞到一份SGI-STL的实现版本（V3.3），撸起袖子，开干</p>
<h1 id="从stl-config-h出发"><a href="#从stl-config-h出发" class="headerlink" title="从stl_config.h出发"></a>从stl_config.h出发</h1><p>这个代码很长，但是大部分都是考虑到不同编译器的不同的性质方面的支持来设置的，用来加强这些代码的可移植性。但是这一节的宏定义太多了，看的我头皮发麻。</p>
<p>那么它都作了一些什么呢</p>
<ol>
<li>如果编译器并不支持bool类型（也就是没有这个内建类型），那么定义  “STL_NO_BOOL” 和 “STL_DONT_USE_BOOL_TYPEDEF”等宏</li>
<li><p>如果编译器的标准链接库᳾支持 drand48()函式，就定定义”STL_NO_DRAND48”，这个drand48()是什么呢？drand48 返回服从均匀分布的·[0.0, 1.0) 之间的 double 型随机数。哇，好强阿，那么大致实现方法是怎么样的呢（这里不再细究防止跑题，以后有时间再开坑研究一下）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">drand48</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </span><br><span class="line">    seed = (<span class="number">0x5DEECE66D</span>LL * <span class="number">1</span> + <span class="number">0xB16</span>) &amp; <span class="number">0xFFFFFFFFFFFF</span>LL; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x = seed &gt;&gt; <span class="number">16</span>;  </span><br><span class="line">    <span class="keyword">return</span>  ((<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="number">0x100000000</span>LL);  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果编译器无法处理 static members of template classes，就定义STL_STATIC_TEMPLATE_MEMBER_BUG</p>
</li>
<li>如果编译器᳾支持关键词 typename，就将’typename’定义为一个 null macro. </li>
<li>如果编译器支持 partial specialization of class templates，就定义“STL_CLASS_PARTIAL_SPECIALIZATION”，这是啥意思呢，根据cplusplusrefence网站的实例，大致如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> &#123;</span>&#125;;            <span class="comment">// primary template</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;T, T*, I&gt; &#123;</span>&#125;;  <span class="comment">// #1: partial specialization where T2 is a pointer to T1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;T*, T2, I&gt; &#123;</span>&#125;; <span class="comment">// #2: partial specialization where T1 is a pointer</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;int, T*, 5&gt; &#123;</span>&#125;; <span class="comment">// #3: partial specialization where T1 is int, I is 5,</span></span><br><span class="line">                        <span class="comment">//     and T2 is a pointer</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">X</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;X, T*, I&gt; &#123;</span>&#125;;   <span class="comment">// #4: partial specialization where T2 is a pointer</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们大部分情况下会使用第一种情况，其他情况（特殊的）都被称之为partial specialization，根据我的理解，就是一层模板套上一层带有模板的成员，用来特化基础形态的（其中）一些模板成员，完全特化就是所有的模板参数都被指定</p>
<ol start="6">
<li>如果编译器支持 partial ordering of function templates（亦称为partial specialization of function templates），就定义STL_FUNCTION_TMPL_PARTIAL_ORDER，这个是函数版本的，大致意思是和第六点类似的</li>
<li>如果编译器允许我们在呼叫一个 function template时可以明白指定其template arguments，就定义STL_EXPLICIT_FUNCTION_TMPL_ARGS</li>
<li>如果编译器支持 template members of classes，就定义STL_MEMBER_TEMPLATES</li>
<li>如果编译器不支持关键词 explicit，就定义’explicit’为一个 null macro</li>
<li>如果编译器无法根据前一个 template parameters设定下一个 template parameters 的默认值，就定义STL_LIMITED_DEFAULT_TEMPLATES</li>
<li>如果编译器针对 non-type template parameters 执行 function template 的自变量推导（argument deduction）时有问题，就定义STL_NON_TYPE_TMPL_PARAM_BUG</li>
<li>如果编译器无法支持迭代器的 operator-&gt;，就定义SGI_STL_NO_ARROW_OPERATOR</li>
<li>如果编译器（在你所选择的模式中）支持 exceptions，就定义STL_USE_EXCEPTIONS</li>
<li>定义STL_USE_NAMESPACES 可使我们自动获得 using std::list;之类的叙句</li>
<li>如果ᴀ链接库由 SGI编译器来编译，而且使用者并未选择 pthreads，或其它 threads，就定义STL_SGI_THREADS.</li>
<li>如果A链接库由一个 WIN32 编译器编译，并且在多绪模式下，就定义STL_WIN32THREADS</li>
<li>适当地定义与 namespace相关的 macros 如STD,STL_BEGIN_NAMESPACE</li>
<li>适当地定义 exception 相关的 macros 如 STL_TRY, STL_UNWIND</li>
<li>根据STL_ASSERTIONS是否定义，将 stl_assert 定义为一个测试动作或一个 null macro</li>
</ol>
<h1 id="stl-config-h全文"><a href="#stl-config-h全文" class="headerlink" title="stl_config.h全文"></a>stl_config.h全文</h1><p>省略了前面的一些注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_CONFIG_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_PTHREADS) &amp;&amp; !defined(_NOTHREADS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PTHREADS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_UITHREADS) &amp;&amp; !defined(_PTHREADS) &amp;&amp; !defined(_NOTHREADS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_UITHREADS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;standards.h&gt;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_BOOL)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BOOL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM == _ABIO32</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_STATIC_CONST_INIT_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_WCHAR_T_IS_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_WCHAR_T </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_TYPENAME_IS_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 730) &amp;&amp; defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM != _ABIO32</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_MEMBER_TEMPLATE_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 730) &amp;&amp; defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM != _ABIO32</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> COMPILER_VERSION &lt; 720 || (defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM == _ABIO32)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &lt; 721) || \</span></span><br><span class="line">    !defined(__STL_HAS_NAMESPACES) || defined(__STL_NO_NAMESPACES)</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &lt; 730 || !defined(_STANDARD_C_PLUS_PLUS) || \</span></span><br><span class="line">      !defined(_NAMESPACES)</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_SGI_THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(_LONGLONG) &amp;&amp; defined(_SGIAPI) &amp;&amp; _SGIAPI</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_LONG_LONG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &gt;= 730 &amp;&amp; defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NEW_IOSTREAMS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &gt;= 730 &amp;&amp; defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CAN_THROW_RANGE_ERRORS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _COMPILER_VERSION &gt;= 730 &amp;&amp; defined(_STANDARD_C_PLUS_PLUS)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __SGI_STL_USE_AUTO_PTR_CONVERSIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jochen Schlick '1999  - added new #defines (__STL)_UITHREADS (for </span></span><br><span class="line"><span class="comment"> *                         providing SCO / Solaris / UI thread support)</span></span><br><span class="line"><span class="comment"> *                       - added the necessary defines for the SCO UDK 7 </span></span><br><span class="line"><span class="comment"> *                         compiler (and its template friend behavior)</span></span><br><span class="line"><span class="comment"> *                       - all UDK7 specific STL changes are based on the </span></span><br><span class="line"><span class="comment"> *                         macro __USLC__ being defined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// SCO UDK 7 compiler (UnixWare 7x, OSR 5, UnixWare 2x)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__USLC__)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_WCHAR_T </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PARTIAL_SPECIALIZATION_SYNTAX</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_LONG_LONG</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">if</span> defined(_REENTRANT)</span></span><br><span class="line"><span class="meta">#           <span class="meta-keyword">define</span> _UITHREADS     <span class="comment">/* if      UnixWare &lt; 7.0.1 */</span></span></span><br><span class="line"><span class="meta">#           <span class="meta-keyword">define</span> __STL_UITHREADS</span></span><br><span class="line"><span class="comment">//   use the following defines instead of the UI threads defines when</span></span><br><span class="line"><span class="comment">//   you want to use POSIX threads</span></span><br><span class="line"><span class="comment">//#         define _PTHREADS      /* only if UnixWare &gt;=7.0.1 */</span></span><br><span class="line"><span class="comment">//#         define __STL_PTHREADS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 7</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ &lt; 2 </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 8</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt;= 8</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CAN_THROW_RANGE_ERRORS</span></span><br><span class="line">      <span class="comment">//    g++ 2.8.1 supports member template functions, but not member</span></span><br><span class="line">      <span class="comment">//    template nested classes.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">if</span> __GNUC_MINOR__ &gt;= 9</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __SGI_STL_USE_AUTO_PTR_CONVERSIONS</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="comment">//#       define __STL_USE_NEW_IOSTREAMS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _REENTRANT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PTHREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (__GNUC__ &lt; 2) || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 95)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_BOOL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _REENTRANT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PTHREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_PARTIAL_SPECIALIZATION_SYNTAX</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__COMO__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Intel compiler, which uses the EDG front end.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__ICL)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_LONG_LONG </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_CLASSES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mingw32, egcs compiler using the Microsoft C runtime</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__MINGW32__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cygwin32, egcs compiler on MS Windows</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__CYGWIN__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Microsoft compiler.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_MSC_VER) &amp;&amp; !defined(__ICL) &amp;&amp; !defined(__MWERKS__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_STATIC_CONST_INIT_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_USING_CLAUSE_IN_CLASS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_FRIEND_TEMPLATE_CLASS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &lt; 1100  <span class="comment">/* 1000 is version 4.0, 1100 is 5.0, 1200 is 6.0. */</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BOOL</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &gt; 1000</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">include</span> <span class="meta-string">&lt;yvals.h&gt;</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DONT_USE_BOOL_TYPEDEF</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &gt;= 1200</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PARTIAL_SPECIALIZATION_SYNTAX</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_HAS_NAMESPACES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CAN_THROW_RANGE_ERRORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> NOMINMAX</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">undef</span> min</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">undef</span> max</span></span><br><span class="line"><span class="comment">// disable warning 'initializers put in unrecognized initialization area'</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> ( disable : 4075 )</span></span><br><span class="line"><span class="comment">// disable warning 'empty controlled statement found'</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> ( disable : 4390 )</span></span><br><span class="line"><span class="comment">// disable warning 'debug symbol greater than 255 chars'</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span> ( disable : 4786 )</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &lt; 1100</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_EXCEPTION_HEADER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Because of a Microsoft front end bug, we must not provide a</span></span><br><span class="line">    <span class="comment">// namespace qualifier when declaring a friend function.</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_QUALIFIER</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__BORLANDC__)</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_BAD_ALLOC</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_CONSTRUCTOR_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __BORLANDC__ &gt;= 0x540 <span class="comment">/* C++ Builder 4.0 */</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_TEMPLATE_FRIENDS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __MT__</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_NO_BOOL) &amp;&amp; !defined(__STL_DONT_USE_BOOL_TYPEDEF)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> false 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_TYPENAME</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> typename</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEPENDENT_DEFAULT_TMPL(_Tp)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_DEPENDENT_DEFAULT_TMPL(_Tp) = _Tp</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATE_KEYWORD</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE template</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_EXPLICIT</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> explicit</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NULL_TMPL_ARGS <span class="meta-string">&lt;&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NULL_TMPL_ARGS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \</span></span><br><span class="line">     || defined (__STL_PARTIAL_SPECIALIZATION_SYNTAX)</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL template<span class="meta-string">&lt;&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use standard-conforming allocators if we have the necessary language</span></span><br><span class="line"><span class="comment">// features.  __STL_USE_SGI_ALLOCATORS is a hook so that users can </span></span><br><span class="line"><span class="comment">// disable new-style allocators, and continue to use the same kind of</span></span><br><span class="line"><span class="comment">// allocators as before, without having to edit library headers.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_CLASS_PARTIAL_SPECIALIZATION) &amp;&amp; \</span></span><br><span class="line">     defined(__STL_MEMBER_TEMPLATES) &amp;&amp; \</span><br><span class="line">     defined(__STL_MEMBER_TEMPLATE_CLASSES) &amp;&amp; \</span><br><span class="line">    !defined(__STL_NO_BOOL) &amp;&amp; \</span><br><span class="line">    !defined(__STL_NON_TYPE_TMPL_PARAM_BUG) &amp;&amp; \</span><br><span class="line">    !defined(__STL_LIMITED_DEFAULT_TEMPLATES) &amp;&amp; \</span><br><span class="line">    !defined(__STL_USE_SGI_ALLOCATORS) </span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) allocator<span class="meta-string">&lt; T &gt;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) alloc</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces</span></span><br><span class="line"><span class="comment">// without having to edit library headers.  __STL_NO_RELOPS_NAMESPACE is</span></span><br><span class="line"><span class="comment">// a hook so that users can disable the std::rel_ops namespace, keeping </span></span><br><span class="line"><span class="comment">// the relational operator template in namespace std, without having to </span></span><br><span class="line"><span class="comment">// edit library headers.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_HAS_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD std</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_NAMESPACE namespace std &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_NAMESPACE &#125;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER) &amp;&amp; \</span></span><br><span class="line">       !defined(__STL_NO_RELOPS_NAMESPACE)</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123; namespace rel_ops &#123;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125; &#125;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STD_RELOPS std::rel_ops</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span> <span class="comment">/* Use std::rel_ops namespace */</span></span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125;</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STD_RELOPS std</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span> <span class="comment">/* Use std::rel_ops namespace */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">undef</span>  __STL_USE_NAMESPACE_FOR_RELOPS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_RELOPS </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">undef</span>  __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some versions of the EDG front end sometimes require an explicit</span></span><br><span class="line"><span class="comment">// namespace spec where they shouldn't.  This macro facilitates that.</span></span><br><span class="line"><span class="comment">// If the bug becomes irrelevant, then all uses of __STD_QUALIFIER</span></span><br><span class="line"><span class="comment">// should be removed.  The 7.3 beta SGI compiler has this bug, but the</span></span><br><span class="line"><span class="comment">// MR version is not expected to have it.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STD_QUALIFIER)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_QUALIFIER std::</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_QUALIFIER</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TRY try</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CATCH_ALL catch(...)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_THROW(x) throw x</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_RETHROW throw</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NOTHROW throw()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_UNWIND(action) catch(...) &#123; action; throw; &#125;</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TRY </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CATCH_ALL <span class="meta-keyword">if</span> (false)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_THROW(x) </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_RETHROW </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NOTHROW </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_UNWIND(action) </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_ASSERTIONS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __stl_assert(expr) \</span></span><br><span class="line">    <span class="keyword">if</span> (!(expr)) &#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s:%d STL assertion failure: %s\n"</span>, \</span><br><span class="line">			  __FILE__, __LINE__, # expr); <span class="built_in">abort</span>(); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __stl_assert(expr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__STL_WIN32THREADS) || defined(__STL_SGI_THREADS) \</span></span><br><span class="line">    || defined(__STL_PTHREADS)  || defined(__STL_UITHREADS)</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_THREADS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_VOLATILE volatile</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_VOLATILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \</span></span><br><span class="line">    &amp;&amp; defined(__STL_MEMBER_TEMPLATES) \</span><br><span class="line">    &amp;&amp; !defined(_STL_NO_CONCEPT_CHECKS)</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __STL_USE_CONCEPT_CHECKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CONFIG_H */</span></span></span><br></pre></td></tr></table></figure>
<h1 id="测试stl-config-h中的宏选项"><a href="#测试stl-config-h中的宏选项" class="headerlink" title="测试stl_config.h中的宏选项"></a>测试stl_config.h中的宏选项</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>我使用的测试代码在我的github repo中fake_stl/test/const_test0.cpp中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">config_test0</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _PTHREADS</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define __STL_PTHREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__sgi begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_BOOL)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_TYPENAME_IS_KEYWORD)</span></span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _MEMBER_TEMPLATES</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_SGI_THREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__sgi end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// # include &lt;_G_config.h&gt; 在现在我使用的版本的gcc(8.2.1)中这个被弃用了，改用stdio.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_STATIC_TEMPLATE_MEMBER_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_FUNCTION_TMPL_PARTIAL_ORDER"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_EXPLICIT_FUNCTION_TMPL_ARGS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it.</span></span><br><span class="line"><span class="comment">       It should be upgraded to glibc 2.0 or later. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_PTHREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SUNPRO_CC begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SUNPRO_CC end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__COMO__)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__COMO__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__COMO__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"_MSC_VER begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> _MSC_VER &gt; 1000</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"include &lt;yvals.h&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NO_DRAND48"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> _MSC_VER &lt; 1100</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NON_TYPE_TMPL_PARAM_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SGI_STL_NO_ARROW_OPERATOR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _MT</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_WIN32THREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"_MSC_VER end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__BORLANDC__)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__BORLANDC__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NO_DRAND48"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_LIMITED_DEFAULT_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__SGI_STL_NO_ARROW_OPERATOR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NON_TYPE_TMPL_PARAM_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _CPPUNWIND</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __MT__</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_WIN32THREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__BORLANDC__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_NEED_BOOL)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"typedef int bool;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define true 1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define false 0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_BOOL end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_TYPENAME</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define typename"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_EXPLICIT</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"define explicit"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NULL_TMPL_ARGS &lt;&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NULL_TMPL_ARGS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TEMPLATE_NULL template&lt;&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TEMPLATE_NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces</span></span><br><span class="line"><span class="comment">// without having to edit library headers.</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD std"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_NAMESPACE namespace std &#123;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_NAMESPACE &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACE_FOR_RELOPS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_RELOPS_NAMESPACE namespace std &#123;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_RELOPS_NAMESPACE &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD_RELOPS std"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACES end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_NAMESPACES begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_NAMESPACE_FOR_RELOPS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_BEGIN_RELOPS_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_END_RELOPS_NAMESPACE "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STD_RELOPS "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_NAMESPACES end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TRY try"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CATCH_ALL catch(...)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_RETHROW throw"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NOTHROW throw()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_UNWIND(action) catch(...) &#123; action; throw; &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_EXCEPTIONS begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_TRY "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CATCH_ALL if (false)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_RETHROW "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NOTHROW "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_UNWIND(action) "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"! __STL_USE_EXCEPTIONS end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_ASSERTIONS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__stl_assert(expr) \</span></span><br><span class="line"><span class="string">    if (!(expr)) &#123; fprintf(stderr, \"%s:%d STL assertion failure: %s\n\", \</span></span><br><span class="line"><span class="string">             __FILE__, __LINE__, # expr); abort(); &#125;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__stl_assert(expr)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    config_test0();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码对应的是gcc2.8那个时代，现在很多代码都不对了，所以有关GNUC的那一段判断我进一步作出了细分（精力有限，其他编译器的选项我都没有看，只看了gcc的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ begin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// # include &lt;_G_config.h&gt; 在现在我使用的版本的gcc(8.2.1)中这个被弃用了，改用stdio.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_STATIC_TEMPLATE_MEMBER_BUG"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_TYPENAME"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_NEED_EXPLICIT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_CLASS_PARTIAL_SPECIALIZATION"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_FUNCTION_TMPL_PARTIAL_ORDER"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_EXPLICIT_FUNCTION_TMPL_ARGS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_MEMBER_TEMPLATES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it.</span></span><br><span class="line"><span class="comment">       It should be upgraded to glibc 2.0 or later. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_PTHREADS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __EXCEPTIONS</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"__STL_USE_EXCEPTIONS"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"__GNUC__ end"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="运行输出结果"><a href="#运行输出结果" class="headerlink" title="运行输出结果"></a>运行输出结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__GNUC__ begin</span><br><span class="line">__STL_USE_EXCEPTIONS</span><br><span class="line">__GNUC__ end</span><br><span class="line"></span><br><span class="line">__STL_NULL_TMPL_ARGS</span><br><span class="line">__STL_TEMPLATE_NULL</span><br><span class="line">! __STL_USE_NAMESPACES begin</span><br><span class="line">__STD </span><br><span class="line">__STL_BEGIN_NAMESPACE </span><br><span class="line">__STL_END_NAMESPACE </span><br><span class="line">__STL_USE_NAMESPACE_FOR_RELOPS</span><br><span class="line">__STL_BEGIN_RELOPS_NAMESPACE </span><br><span class="line">__STL_END_RELOPS_NAMESPACE </span><br><span class="line">__STD_RELOPS </span><br><span class="line">! __STL_USE_NAMESPACES end</span><br><span class="line"></span><br><span class="line">! __STL_USE_EXCEPTIONS begin</span><br><span class="line">__STL_TRY </span><br><span class="line">__STL_CATCH_ALL if (false)</span><br><span class="line">__STL_RETHROW </span><br><span class="line">__STL_NOTHROW </span><br><span class="line">__STL_UNWIND(action) </span><br><span class="line">! __STL_USE_EXCEPTIONS end</span><br><span class="line"></span><br><span class="line">__stl_assert(expr)</span><br></pre></td></tr></table></figure>
<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> lsb_release -a</span><br><span class="line">LSB Version:    1.4</span><br><span class="line">Distributor ID: Arch</span><br><span class="line">Description:    Arch Linux</span><br><span class="line">Release:        rolling</span><br><span class="line">Codename:       n/a</span><br><span class="line"><span class="meta">$</span> gcc --version</span><br><span class="line">gcc (GCC) 8.2.1 20180831</span><br><span class="line">Copyright © 2018 Free Software Foundation, Inc.</span><br><span class="line">本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；</span><br><span class="line">包括没有适销性和某一专用目的下的适用性担保。</span><br><span class="line"><span class="meta">$</span> g++ --version</span><br><span class="line">g++ (GCC) 8.2.1 20180831</span><br><span class="line">Copyright © 2018 Free Software Foundation, Inc.</span><br><span class="line">本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；</span><br><span class="line">包括没有适销性和某一专用目的下的适用性担保。</span><br></pre></td></tr></table></figure>
<p>由此来看，gcc的能力十分强悍，很多轮子不需要自己造</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/25/redis-0-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hall">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hall">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/25/redis-0-md/" class="post-title-link" itemprop="url">redis(0):the installation and test of redis utils</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-25 03:56:25" itemprop="dateCreated datePublished" datetime="2018-11-25T03:56:25+08:00">2018-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 18:10:45" itemprop="dateModified" datetime="2022-03-13T18:10:45+08:00">2022-03-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux下C-操作redis入门配置和测试"><a href="#Linux下C-操作redis入门配置和测试" class="headerlink" title="Linux下C++操作redis入门配置和测试"></a>Linux下C++操作redis入门配置和测试</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Redis、Key-Value数据库，并提供多种语言的API。基于内存这一点特性使得它速度很快，在实际项目中常用来作为缓存，队列，数据库来使用。</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>x86_64 Linux 4.19.2-arch1-1-ARCH</li>
</ul>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ul>
<li><p>第一步，安装redis数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，运行redis.service</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你不知道redis进程所用的端口，你可以查看/etc/redis.conf文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redis.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者查看进程占用端口情况,一般默认的是6379</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，你可以下载可用的接口和源代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/redis/hiredis</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进入文件夹并进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hiredis</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样你会得到一个动态链接库文件(.so)</p>
</li>
<li><p>你在使用这些接口的时候，你可以在和hiredis同级的文件夹中的cpp文件写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include "hiredis/hiredis.h"</span><br></pre></td></tr></table></figure>
</li>
<li><p>之前看到网上有博客写要加extern “C”,但是我看一下hiredis.h头文件,作者已经考虑到C++的使用问题，所以其实可以不加</p>
</li>
<li><p>假设你在和hiredis同级的文件夹下要编译的文件名为redis_test.cpp, 那么你编译的时候应该记得链接上libhiredis.so</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ redis_test.cpp hiredis/libhiredis.so -o redis_test.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>你还可以手动建立/usr/include/hiredis 和/usr/lib/hiredis文件夹，然后分别把hiredis.h和libhiredis.so移动到二者下面</p>
</li>
<li><p>这样的话当前版本的hiredis接口就是全局可用的，但是每次编译的时候貌似还是要带上”-lhiredis”参数</p>
</li>
<li><p>在Archlinux中，你可以用pacman直接安装hiredis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S hiredis</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后直接编译测试代码就好了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ redis_test.cpp -o redis_test -lhiredis</span><br></pre></td></tr></table></figure>
</li>
<li><p>跑一下这个编译之后的可执行程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./redis_test</span><br><span class="line">test finished</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><ul>
<li>这段代码意思还是挺直白的，就是建立一个链接，发送一个命令，然后看回复的类型，然后释放链接</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile parameter: -lhiredis</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    redisContext* context = redisConnect(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">if</span>(!context || context-&gt;err) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; context-&gt;errstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cmd = <span class="string">"redis demo"</span>;</span><br><span class="line">    redisReply* reply = (redisReply*) redisCommand(context, cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!reply) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        redisFree(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(reply-&gt;type == REDIS_REPLY_STATUS)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the status of the context reply is "</span> &lt;&lt; reply-&gt;str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test finished"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hall</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hall</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
